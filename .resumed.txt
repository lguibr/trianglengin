File: LICENSE

MIT License

Copyright (c) 2025 Luis Guilherme P. M.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

File: pyproject.toml
# File: pyproject.toml
[build-system]
requires = [
    "setuptools>=61.0", # Keep >=61 for find_packages support if needed, >=77 for new license format preferred
    "wheel",
    "pybind11>=2.10",
    "cmake>=3.14",
]
build-backend = "setuptools.build_meta"

[project]
name = "trianglengin"
version = "2.0.4" # Incremented version
authors = [{ name="Luis Guilherme P. M.", email="lgpelin92@gmail.com" }]
description = "High-performance C++/Python engine for a triangle puzzle game." # Updated description
readme = "README.md"
# Use SPDX identifier string and specify license file(s)
license = "MIT"
license-files = ["LICENSE"]
requires-python = ">=3.10"
classifiers = [
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: C++", # Added C++ classifier
    # REMOVED: "License :: OSI Approved :: MIT License", # Deprecated classifier
    "Operating System :: OS Independent",
    "Topic :: Scientific/Engineering :: Artificial Intelligence",
    "Topic :: Games/Entertainment :: Puzzle Games",
    "Development Status :: 4 - Beta",
]
dependencies = [
    # Core dependencies + UI dependencies are now required
    "numpy>=1.20.0",
    "pydantic>=2.0.0",
    "typing_extensions>=4.0.0",
    "pygame>=2.1.0",
    "typer[all]>=0.9.0",
]

[project.urls]
"Homepage" = "https://github.com/lguibr/trianglengin"
"Bug Tracker" = "https://github.com/lguibr/trianglengin/issues"

[project.scripts]
# Script now points to the CLI inside the 'ui' subpackage
trianglengin = "trianglengin.ui.cli:app"

[project.optional-dependencies]
# UI section removed
dev = [
    "pytest>=7.0.0",
    "pytest-cov>=3.0.0",
    "pytest-mock>=3.0.0",
    "ruff",
    "mypy",
    "build",
    "twine",
    "codecov",
    # No need to list pygame/typer here anymore
]

[tool.setuptools]
# package_dir is removed from here - handled by setup.py
# include-package-data = true # Optional: Keep if you rely on MANIFEST.in for data files

[tool.setuptools.package-data]
# Include C++ headers if needed, py.typed, etc.
"trianglengin" = ["py.typed", "cpp/*.h"]

# --- Tool Configurations ---

[tool.ruff]
line-length = 88
src = ["src", "tests"] # Specify source directories

[tool.ruff.lint]
select = ["E", "W", "F", "I", "UP", "B", "C4", "ARG", "SIM", "TCH", "PTH", "NPY", "PYI"] # Added PYI for stubs
ignore = ["E501"]

[tool.ruff.format]
quote-style = "double"

[tool.mypy]
python_version = "3.10"
warn_return_any = true
warn_unused_configs = true
ignore_missing_imports = false # Be stricter
disallow_untyped_defs = true
# Specify source directory for mypy
files = ["src/trianglengin", "tests"]

[[tool.mypy.overrides]]
# Ignore the compiled C++ extension module
module = "trianglengin.trianglengin_cpp"
ignore_missing_imports = true

# No longer need overrides for pygame/typer as they are required


[tool.pytest.ini_options]
minversion = "7.0"
# Update coverage path
addopts = "-ra -q --cov=src/trianglengin --cov-report=term-missing"
testpaths = [
    "tests",
]

[tool.coverage.run]
source = ["src/trianglengin"] # Specify source for coverage
omit = [
    "src/trianglengin/__init__.py",
    "src/trianglengin/cpp/*", # Exclude C++ source from Python coverage
    "src/trianglengin/config/env_config.py", # Keep config covered (only env_config)
    "src/trianglengin/utils/types.py",
    # Omit the entire UI package
    "src/trianglengin/ui/*",
    # Omit the now empty core package
    "src/trianglengin/core/*",
    "tests/*",
    "setup.py",
]

[tool.coverage.report]
fail_under = 70 # Increased target coverage for core logic
show_missing = true

# Optional: Add cibuildwheel configuration if needed
# [tool.cibuildwheel]
# skip = "pp*"  # Example: Skip PyPy builds
# test-requires = "pytest" # Dependencies needed for tests run by cibuildwheel
# test-command = "pytest {project}/tests" # Command to run tests after building wheel

File: MANIFEST.in

# File: MANIFEST.in
include README.md
include LICENSE
include pyproject.toml
include setup.py

# Include Python source files from src directory
graft src/trianglengin
# Include all tests generically
graft tests

# Include C++ source files and CMakeLists.txt
graft src/trianglengin/cpp

# Include the py.typed marker file
include src/trianglengin/py.typed

# Exclude specific files no longer present
exclude src/trianglengin/config/display_config.py
exclude src/trianglengin/core/environment/shapes/templates.py

# Exclude build artifacts and caches
global-exclude __pycache__ *.py[co] *.so *.pyd *.dylib *.egg-info CMakeCache.txt CMakeFiles
prune build
prune dist

File: README.md

[![CI Status](https://github.com/lguibr/trianglengin/actions/workflows/ci_cd.yml/badge.svg)](https://github.com/lguibr/trianglengin/actions/workflows/ci_cd.yml)
[![codecov](https://codecov.io/gh/lguibr/trianglengin/graph/badge.svg?token=YOUR_CODECOV_TOKEN_HERE&flag=trianglengin)](https://codecov.io/gh/lguibr/trianglengin)
[![PyPI version](https://badge.fury.io/py/trianglengin.svg)](https://badge.fury.io/py/trianglengin)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Python Version](https://img.shields.io/badge/python-3.10+-blue.svg)](https://www.python.org/downloads/)

# Triangle Engine (`trianglengin`) v2.0.3
<img src="bitmap.png" alt="trianglengin logo" width="300"/>

**Version 2 introduces a high-performance C++ core for the game logic.**

This library provides the core components for a triangle puzzle game, suitable for reinforcement learning agents or other applications requiring a fast game engine. Interactive play/debug modes are included.

It encapsulates:

1.  **Core Game Logic (C++):** High-performance implementation of environment rules, state representation, actions, placement validation, and line clearing. ([`src/trianglengin/cpp/README.md`](src/trianglengin/cpp/README.md))
2.  **Python Interface:** A Python `GameState` wrapper providing a user-friendly API to interact with the C++ core. ([`src/trianglengin/game_interface.py`](src/trianglengin/game_interface.py))
3.  **Configuration (Python/Pydantic):** Models for environment settings (`EnvConfig`). ([`src/trianglengin/config/README.md`](src/trianglengin/config/README.md))
4.  **Utilities (Python):** General helpers, geometry functions, shared types. ([`src/trianglengin/utils/README.md`](src/trianglengin/utils/README.md))
5.  **UI Components (Python/Pygame/Typer):** Basic visualization, interaction handling, and CLI for interactive modes. ([`src/trianglengin/ui/README.md`](src/trianglengin/ui/README.md))

---

## ðŸŽ® The Ultimate Triangle Puzzle Guide ðŸ§©

*(Game rules remain the same)*

*(... Game rules section remains unchanged ...)*

---

## Purpose

The primary goal is to provide a self-contained, installable library with a high-performance C++ core and a Python interface for the triangle puzzle game. This allows different RL agent implementations or other applications to build upon a consistent and fast game backend. The interactive UI is included but only initialized when running the specific UI commands.

## Installation

**Prerequisites:**
*   A C++ compiler supporting C++17 (e.g., GCC, Clang, MSVC).
*   CMake (version 3.14 or higher).
*   Python (>= 3.10) and Pip.

```bash
# For standard use (once published or built):
pip install trianglengin>=2.0.3

# Building from source (requires compiler and CMake):
git clone https://github.com/lguibr/trianglengin.git
cd trianglengin
pip install .
```
*(Note: `pygame` and `typer` will be installed as core dependencies).*

## Running Interactive Modes

After installing, you can run the interactive modes directly:

- **Play Mode:**
  ```bash
  trianglengin play [--seed 42] [--log-level INFO]
  ```
- **Debug Mode:**
  ```bash
  trianglengin debug [--seed 42] [--log-level DEBUG]
  ```

---

## Local Development & Testing

These instructions are for developers contributing to `trianglengin`.

1.  **Clone the Repository:**
    ```bash
    git clone https://github.com/lguibr/trianglengin.git
    cd trianglengin
    ```

2.  **Prerequisites:** Ensure you have a C++17 compiler and CMake installed.

3.  **Create and Activate Virtual Environment:** (venv or conda)
    ```bash
    # Example using venv
    python -m venv venv
    source venv/bin/activate # or .\venv\Scripts\activate on Windows
    ```
    **IMPORTANT:** Ensure your virtual environment is activated.

4.  **Install Build Dependencies:** (Needed even for core dev)
    ```bash
    pip install pybind11>=2.10 cmake wheel
    ```

5.  **Clean Previous Builds (Optional but Recommended):**
    ```bash
    rm -rf build/ src/trianglengin.egg-info/ dist/ src/trianglengin/trianglengin_cpp.*.so src/trianglengin/trianglengin_cpp*.cpp
    ```

6.  **Install in Editable Mode with Dev Dependencies:**
    *   **Make sure your virtual environment is active!**
    *   Run from the project root directory:
        ```bash
        # Installs core, UI, and dev tools
        pip install -e '.[dev]'
        ```
        This command compiles the C++ extension and installs the Python package so changes are reflected immediately. It also installs development tools.

7.  **Running Checks:**
    *   **Make sure your virtual environment is active!**
    *   **Tests & Coverage:**
        ```bash
        pytest tests/ --cov=src/trianglengin --cov-report=xml
        ```
        (Coverage measures core Python code, excluding UI).
        To just run tests: `pytest`
    *   **Linting:** `ruff check .`
    *   **Formatting:** `ruff format .`
    *   **Type Checking:** `mypy src/trianglengin/ tests/`

8.  **Troubleshooting Build/Import Errors:**
    *   Ensure compiler and CMake are installed and in PATH.
    *   Make sure the virtual environment is active *before* running `pip install -e`.
    *   Clean previous builds (Step 5).
    *   Check `pyproject.toml` and `setup.py` for correct configuration.
    *   Verify Pybind11 version compatibility.

---

## Project Structure (v2 - UI Included)

```
trianglengin/
â”œâ”€â”€ .github/workflows/      # GitHub Actions CI/CD
â”‚   â””â”€â”€ ci_cd.yml
â”œâ”€â”€ src/                    # Source root
â”‚   â””â”€â”€ trianglengin/       # Python package source
â”‚       â”œâ”€â”€ __init__.py     # Exposes core public API (GameState, EnvConfig, Shape)
â”‚       â”œâ”€â”€ game_interface.py # Python GameState wrapper class
â”‚       â”œâ”€â”€ py.typed        # PEP 561 marker
â”‚       â”œâ”€â”€ cpp/            # C++ Core Implementation ([src/trianglengin/cpp/README.md])
â”‚       â”‚   â”œâ”€â”€ CMakeLists.txt
â”‚       â”‚   â”œâ”€â”€ bindings.cpp
â”‚       â”‚   â”œâ”€â”€ config.h
â”‚       â”‚   â”œâ”€â”€ structs.h
â”‚       â”‚   â”œâ”€â”€ grid_data.h / .cpp
â”‚       â”‚   â”œâ”€â”€ grid_logic.h / .cpp
â”‚       â”‚   â”œâ”€â”€ shape_logic.h / .cpp
â”‚       â”‚   â””â”€â”€ game_state.h / .cpp
â”‚       â”œâ”€â”€ core/           # Core Python components (now minimal/empty)
â”‚       â”‚   â””â”€â”€ __init__.py
â”‚       â”œâ”€â”€ utils/          # General Python utilities ([src/trianglengin/utils/README.md])
â”‚       â”‚   â””â”€â”€ ... (geometry.py, types.py)
â”‚       â”œâ”€â”€ config/         # Core configuration models ([src/trianglengin/config/README.md])
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â””â”€â”€ env_config.py   # EnvConfig (Pydantic)
â”‚       â””â”€â”€ ui/             # UI Components ([src/trianglengin/ui/README.md])
â”‚           â”œâ”€â”€ __init__.py # Exposes UI API (Application, cli_app, DisplayConfig)
â”‚           â”œâ”€â”€ app.py      # Interactive mode application runner
â”‚           â”œâ”€â”€ cli.py      # CLI definition (play/debug)
â”‚           â”œâ”€â”€ config.py   # DisplayConfig (Pydantic)
â”‚           â”œâ”€â”€ interaction/    # User input handling ([src/trianglengin/ui/interaction/README.md])
â”‚           â”‚   â”œâ”€â”€ __init__.py
â”‚           â”‚   â”œâ”€â”€ event_processor.py
â”‚           â”‚   â”œâ”€â”€ input_handler.py
â”‚           â”‚   â”œâ”€â”€ play_mode_handler.py
â”‚           â”‚   â””â”€â”€ debug_mode_handler.py
â”‚           â””â”€â”€ visualization/  # Pygame rendering ([src/trianglengin/ui/visualization/README.md])
â”‚               â”œâ”€â”€ __init__.py
â”‚               â”œâ”€â”€ core/       # Core vis components ([src/trianglengin/ui/visualization/core/README.md])
â”‚               â”‚   â”œâ”€â”€ __init__.py
â”‚               â”‚   â”œâ”€â”€ colors.py
â”‚               â”‚   â”œâ”€â”€ coord_mapper.py
â”‚               â”‚   â”œâ”€â”€ fonts.py
â”‚               â”‚   â”œâ”€â”€ layout.py # NEW
â”‚               â”‚   â””â”€â”€ visualizer.py
â”‚               â””â”€â”€ drawing/    # Drawing functions ([src/trianglengin/ui/visualization/drawing/README.md])
â”‚                   â”œâ”€â”€ __init__.py
â”‚                   â”œâ”€â”€ grid.py
â”‚                   â”œâ”€â”€ highlight.py
â”‚                   â”œâ”€â”€ hud.py
â”‚                   â”œâ”€â”€ previews.py
â”‚                   â”œâ”€â”€ shapes.py
â”‚                   â””â”€â”€ utils.py
â”œâ”€â”€ tests/                  # Unit/Integration tests (Python) ([tests/README.md])
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ conftest.py
â”‚   â””â”€â”€ core/environment/
â”‚       â””â”€â”€ test_game_state.py # Tests the Python GameState wrapper
â”œâ”€â”€ .gitignore
â”œâ”€â”€ pyproject.toml          # Build config, dependencies
â”œâ”€â”€ setup.py                # C++ Extension build script
â”œâ”€â”€ README.md               # This file
â”œâ”€â”€ LICENSE
â””â”€â”€ MANIFEST.in
```

## Core Components (v2)

- **`trianglengin.cpp` (C++ Core)**: Implements the high-performance game logic (state, grid, shapes, rules). Not directly imported in Python.
- **`trianglengin.game_interface.GameState` (Python Wrapper)**: The primary Python class for interacting with the game engine. It holds a reference to the C++ game state object and provides methods like `step`, `reset`, `is_over`, `valid_actions`, `get_shapes`, `get_grid_data_np`, **`get_outcome`**.
- **`trianglengin.config.EnvConfig`**: Python Pydantic model for core environment configuration. Passed to C++ core during initialization.
- **`trianglengin.utils`**: General Python utility functions and types. ([`src/trianglengin/utils/README.md`](src/trianglengin/utils/README.md))

## UI Components (`trianglengin.ui`)

- **`trianglengin.ui.config.DisplayConfig`**: Pydantic model for UI display settings.
- **`trianglengin.ui.visualization`**: Python/Pygame rendering components. Uses data obtained from the `GameState` wrapper. ([`src/trianglengin/ui/visualization/README.md`](src/trianglengin/ui/visualization/README.md))
- **`trianglengin.ui.interaction`**: Python/Pygame input handling for interactive modes. Interacts with the `GameState` wrapper. ([`src/trianglengin/ui/interaction/README.md`](src/trianglengin/ui/interaction/README.md))
- **`trianglengin.ui.app.Application`**: Integrates UI components for interactive modes.
- **`trianglengin.ui.cli`**: Command-line interface (`trianglengin play`/`debug`).

## Contributing

Contributions are welcome! Please open an issue or submit a pull request on the [GitHub repository](https://github.com/lguibr/trianglengin). Ensure that changes maintain code quality (pass tests, linting, type checking) and keep READMEs updated. Building requires a C++17 compiler and CMake.


File: setup.py
# File: setup.py
import os
import re
import shutil
import subprocess
import sys
from pathlib import Path

# Import pybind11 BEFORE setuptools
import pybind11
from setuptools import Extension, find_packages, setup
from setuptools.command.build_ext import build_ext
from setuptools.command.develop import develop as _develop

# REMOVED: Unused PLAT_TO_CMAKE dictionary
# PLAT_TO_CMAKE = {
#     "win32": "Win32",
#     "win-amd64": "x64",
#     "win-arm32": "ARM",
#     "win-arm64": "ARM64",
# }


# A CMakeExtension needs a sourcedir instead of a file list.
class CMakeExtension(Extension):
    def __init__(self, name: str, sourcedir: str = "") -> None:
        super().__init__(name, sources=[])
        self.sourcedir = os.fspath(Path(sourcedir).resolve())


class CMakeBuild(build_ext):
    def build_extension(self, ext: CMakeExtension) -> None:
        ext_fullpath = Path(self.get_ext_fullpath(ext.name)).resolve()
        extdir = ext_fullpath.parent.resolve()

        cmake_generator = os.environ.get("CMAKE_GENERATOR", "")
        cfg = "Debug" if self.debug else "Release"
        python_executable = sys.executable
        pybind11_cmake_dir = pybind11.get_cmake_dir()

        if not Path(pybind11_cmake_dir).exists():
            raise RuntimeError(
                f"Could not find Pybind11 CMake directory: {pybind11_cmake_dir}"
            )
        print(f"Found Pybind11 CMake directory: {pybind11_cmake_dir}")

        is_multi_config = any(x in cmake_generator for x in {"Visual Studio", "Xcode"})
        cmake_library_output_dir = extdir
        if is_multi_config and self.compiler.compiler_type == "msvc":
            cmake_library_output_dir = extdir.joinpath(cfg)
            cmake_library_output_dir.mkdir(parents=True, exist_ok=True)

        cmake_args = [
            f"-DCMAKE_LIBRARY_OUTPUT_DIRECTORY={cmake_library_output_dir}",
            f"-DPython_EXECUTABLE={python_executable}",
            f"-DCMAKE_BUILD_TYPE={cfg}",
            f"-Dpybind11_DIR={pybind11_cmake_dir}",
        ]

        if sys.platform.startswith("darwin"):
            archs = re.findall(r"-arch (\S+)", os.environ.get("ARCHFLAGS", ""))
            if archs:
                cmake_args += ["-DCMAKE_OSX_ARCHITECTURES={}".format(";".join(archs))]

        if "CMAKE_ARGS" in os.environ:
            cmake_args += [item for item in os.environ["CMAKE_ARGS"].split(" ") if item]

        cmake_args += [f"-DTRIANGLENGIN_VERSION_INFO={self.distribution.get_version()}"]

        build_args = ["--config", cfg]

        # Combine nested ifs using 'and'
        if self.compiler.compiler_type == "msvc" and not any(
            x in cmake_generator for x in {"NMake", "Ninja"}
        ):
            # REMOVED: Do not force architecture with -A; let cibuildwheel/CMake handle it.
            # cmake_args += ["-A", PLAT_TO_CMAKE[self.plat_name]]
            build_args += ["--", "/m"]  # Keep multi-process build for MSVC

        # Combine nested ifs using 'and'
        if (
            "CMAKE_BUILD_PARALLEL_LEVEL" not in os.environ
            and hasattr(self, "parallel")
            and self.parallel
        ):
            build_args += [f"-j{self.parallel}"]

        build_temp = Path(self.build_temp) / ext.name
        build_temp.mkdir(parents=True, exist_ok=True)

        print("-" * 10, "Running CMake prepare", "-" * 40)
        print(f"CMake command: cmake {ext.sourcedir} {' '.join(cmake_args)}")
        subprocess.run(
            ["cmake", ext.sourcedir, *cmake_args],
            cwd=build_temp,
            check=True,
        )

        print("-" * 10, "Building extension", "-" * 43)
        print(f"Build command: cmake --build . {' '.join(build_args)}")
        subprocess.run(
            ["cmake", "--build", ".", *build_args],
            cwd=build_temp,
            check=True,
        )
        print("-" * 10, "Finished building extension", "-" * 36)

        # Fallback copy mechanism (adapted from trimcts)
        if not ext_fullpath.exists():
            print(f"Extension not found at expected path: {ext_fullpath}")
            print(f"Searching in build temp: {build_temp}")
            module_name = ext.name.split(".")[-1]
            found = False
            for suffix in (".so", ".dylib", ".pyd"):
                candidates = list(build_temp.rglob(f"*{module_name}*{suffix}"))
                if candidates:
                    built = candidates[0]
                    print(f"Found candidate in build temp: {built}")
                    print(f"Copying built extension from: {built} -> {ext_fullpath}")
                    ext_fullpath.parent.mkdir(parents=True, exist_ok=True)
                    shutil.copy2(built, ext_fullpath)
                    found = True
                    break
            if not found:
                print(f"Searching in extdir: {extdir}")
                for suffix in (".so", ".dylib", ".pyd"):
                    candidates = list(extdir.rglob(f"{module_name}*{suffix}"))
                    if candidates:
                        built = candidates[0]
                        print(f"Found candidate in extdir: {built}")
                        print(
                            f"Copying built extension from: {built} -> {ext_fullpath}"
                        )
                        ext_fullpath.parent.mkdir(parents=True, exist_ok=True)
                        shutil.copy2(built, ext_fullpath)
                        found = True
                        break

            if not found:
                raise RuntimeError(
                    f"Could not find built extension {module_name}.* in {extdir} or {build_temp}"
                )
        else:
            print(f"Found built extension at target: {ext_fullpath}")


class Develop(_develop):
    """Run CMake build_ext as part of 'python setup.py develop'."""

    def run(self) -> None:
        self.run_command("build_ext")
        super().run()


setup(
    # Metadata defined in pyproject.toml
    packages=find_packages(where="src"),
    package_dir={"": "src"},
    package_data={
        "trianglengin": ["py.typed", "cpp/*.h"]
    },  # Include headers and py.typed
    ext_modules=[
        CMakeExtension(
            "trianglengin.trianglengin_cpp", sourcedir="src/trianglengin/cpp"
        )
    ],
    cmdclass={
        "build_ext": CMakeBuild,
        "develop": Develop,
    },
    zip_safe=False,
)


File: .python-version
3.10.13


File: .pytest_cache/CACHEDIR.TAG
Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by pytest.
# For information about cache directory tags, see:
#	https://bford.info/cachedir/spec.html


File: .pytest_cache/README.md
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.


File: .ruff_cache/CACHEDIR.TAG
Signature: 8a477f597d28d172789f06886806bc55

File: tests/conftest.py
# File: tests/conftest.py
import random
from collections.abc import Generator

import pytest

from trianglengin.config import EnvConfig

# Use new interface types
from trianglengin.game_interface import GameState, Shape

# Import moved DisplayConfig if needed by UI tests (not needed here)
# from trianglengin.ui.config import DisplayConfig
# Import colors from the core vis module (if needed by fixtures)
# Note: Colors are now part of UI, avoid using them in core tests if possible
# from trianglengin.ui.visualization.core import colors

# Default color for fixture shapes
DEFAULT_TEST_COLOR = (100, 100, 100)  # Keep as tuple
DEFAULT_TEST_COLOR_ID = -10  # Assign an arbitrary negative ID for test shapes


@pytest.fixture(scope="session")
def default_env_config() -> EnvConfig:
    """Provides the default EnvConfig used in the specification (session-scoped)."""
    return EnvConfig()


@pytest.fixture
def game_state(default_env_config: EnvConfig) -> GameState:
    """Provides a fresh GameState wrapper instance for testing."""
    return GameState(config=default_env_config, initial_seed=123)


@pytest.fixture
def game_state_3x3() -> GameState:
    """Provides a game state wrapper for a 3x3 grid."""
    config_3x3 = EnvConfig(
        ROWS=3,
        COLS=3,
        PLAYABLE_RANGE_PER_ROW=[(0, 3), (0, 3), (0, 3)],
        NUM_SHAPE_SLOTS=3,
    )
    return GameState(config=config_3x3, initial_seed=456)


@pytest.fixture
def game_state_4x4() -> GameState:
    """Provides a game state wrapper for a 4x4 grid."""
    config_4x4 = EnvConfig(
        ROWS=4,
        COLS=4,
        PLAYABLE_RANGE_PER_ROW=[(0, 4), (0, 4), (0, 4), (0, 4)],
        NUM_SHAPE_SLOTS=3,
    )
    return GameState(config=config_4x4, initial_seed=789)


@pytest.fixture
def simple_shape() -> Shape:
    """Provides a simple 3-triangle connected shape (Down, Up, Down)."""
    triangles = [(0, 0, False), (0, 1, True), (1, 1, False)]
    color = (255, 0, 0)
    # Use the new Shape constructor
    return Shape(triangles, color, color_id=0)


@pytest.fixture
def single_up_triangle_shape() -> Shape:
    """Provides a shape consisting of a single Up triangle."""
    triangles = [(0, 0, True)]
    color = (0, 255, 0)  # Green
    return Shape(triangles, color, color_id=2)  # Assign an ID


@pytest.fixture
def game_state_almost_full(
    default_env_config: EnvConfig,
) -> Generator[GameState, None, None]:
    """
    Provides a game state (default config) where only a few placements are possible.
    Uses debug_toggle_cell to fill the grid.
    Yields the state and resets it afterwards.
    """
    gs = GameState(config=default_env_config, initial_seed=987)
    grid_data_np = gs.get_grid_data_np()
    rows, cols = grid_data_np["death"].shape

    for r in range(rows):
        for c in range(cols):
            if not grid_data_np["death"][r, c]:
                current_grid_data = gs.get_grid_data_np()
                if not current_grid_data["occupied"][r, c]:
                    gs.debug_toggle_cell(r, c)

    empty_spots = [(0, 4), (0, 5)]
    for r_empty, c_empty in empty_spots:
        current_grid_data = gs.get_grid_data_np()
        if (
            r_empty < gs.env_config.ROWS
            and c_empty < gs.env_config.COLS
            and not current_grid_data["death"][r_empty, c_empty]
            and current_grid_data["occupied"][r_empty, c_empty]
        ):
            gs.debug_toggle_cell(r_empty, c_empty)

    yield gs


@pytest.fixture
def fixed_rng() -> random.Random:
    """Provides a Random instance with a fixed seed."""
    return random.Random(12345)


File: tests/__init__.py


File: tests/core/__init__.py
# File: trianglengin/tests/core/__init__.py
# This file can be empty


File: tests/core/environment/__init__.py
# File: trianglengin/tests/core/environment/__init__.py
# This file can be empty


File: tests/core/environment/README.md
# File: tests/core/environment/README.md
# Environment Tests (`tests/core/environment`)

## Purpose

This directory contains tests specifically for the game environment's core functionality, primarily focusing on the **Python `GameState` wrapper** which interacts with the underlying C++ engine.

-   **[`test_game_state.py`](test_game_state.py):** This is the main test suite. It verifies the behavior of the `trianglengin.game_interface.GameState` Python class. Tests cover:
    -   Initialization and reset.
    -   Valid and invalid `step` calls.
    -   Score calculation (placement, line clearing, penalties).
    -   Game over conditions (`is_over`, `get_game_over_reason`).
    -   Retrieval of state information (`get_grid_data_np`, `get_shapes`).
    -   Valid action calculation (`valid_actions`).
    -   State copying (`copy`).
    -   Debug functionality (`debug_toggle_cell`).

## Approach

Since the core game logic (grid operations, shape handling, line clearing, action validation) is implemented in C++, these tests primarily focus on ensuring the Python wrapper correctly interfaces with the C++ module (`trianglengin_cpp`). They validate that:

1.  Python methods call the corresponding C++ functions.
2.  Data is correctly transferred between Python and C++ (e.g., configurations, grid state, shapes, actions, rewards).
3.  The wrapper handles edge cases and errors appropriately (e.g., invalid actions).
4.  The overall game flow (steps, resets, game over) behaves as expected from the Python perspective.

Direct testing of individual C++ functions or classes would typically be done using a C++ testing framework (like Google Test), which is outside the scope of these Python tests.

## Dependencies

-   **`pytest`**: Test runner and fixtures.
-   **`numpy`**: Used for checking grid data arrays.
-   **`trianglengin.game_interface`**: The `GameState` wrapper and `Shape` class being tested.
-   **`trianglengin.config`**: `EnvConfig` used for setup.

---

**Note:** Keep this README updated if the testing strategy changes or significant new test files related to the environment wrapper are added.

File: tests/core/environment/test_game_state.py
# File: tests/core/environment/test_game_state.py
import logging

import numpy as np
import pytest

from trianglengin.game_interface import GameState, Shape  # Import Shape

logging.basicConfig(level=logging.INFO)


# --- Helper Functions ---
def get_first_valid_action(gs: GameState) -> int | None:
    """Helper to get the first available valid action."""
    valid_actions = gs.valid_actions()
    return next(iter(valid_actions), None)


def count_non_none_shapes(gs: GameState) -> int:
    """Counts shapes currently in the preview slots."""
    return sum(1 for s in gs.get_shapes() if s is not None)


# Helper to encode action (matches C++ logic)
def encode_action(shape_idx: int, r: int, c: int, gs: GameState) -> int:
    """Encodes action based on game state config."""
    config = gs.env_config
    grid_size = config.ROWS * config.COLS
    if not (
        0 <= shape_idx < config.NUM_SHAPE_SLOTS
        and 0 <= r < config.ROWS
        and 0 <= c < config.COLS
    ):
        return -1
    return shape_idx * grid_size + r * config.COLS + c


# --- Tests for the GameState Wrapper ---


def test_game_state_initialization(game_state: GameState) -> None:
    """Test basic initialization of the GameState wrapper."""
    assert game_state.env_config is not None
    assert game_state.game_score() == 0.0
    assert game_state.current_step == 0
    grid_data = game_state.get_grid_data_np()
    assert isinstance(grid_data, dict)
    assert "occupied" in grid_data and isinstance(grid_data["occupied"], np.ndarray)
    assert "color_id" in grid_data and isinstance(grid_data["color_id"], np.ndarray)
    assert "death" in grid_data and isinstance(grid_data["death"], np.ndarray)
    assert grid_data["occupied"].shape == (
        game_state.env_config.ROWS,
        game_state.env_config.COLS,
    )
    assert grid_data["color_id"].shape == (
        game_state.env_config.ROWS,
        game_state.env_config.COLS,
    )
    assert grid_data["death"].shape == (
        game_state.env_config.ROWS,
        game_state.env_config.COLS,
    )
    shapes = game_state.get_shapes()
    assert isinstance(shapes, list)
    assert len(shapes) == game_state.env_config.NUM_SHAPE_SLOTS
    is_initially_over = game_state.is_over()
    initial_valid_actions = game_state.valid_actions()
    if is_initially_over:
        assert not initial_valid_actions
        reason = game_state.get_game_over_reason()
        assert reason is not None and "start" in reason.lower()
    else:
        assert initial_valid_actions
        assert game_state.get_game_over_reason() is None


def test_game_state_reset(game_state: GameState) -> None:
    """Test resetting the GameState wrapper."""
    initial_shapes_before_step = game_state.get_shapes()
    action = get_first_valid_action(game_state)
    if action is not None:
        game_state.step(action)
        assert game_state.game_score() != 0.0 or game_state.is_over()
        assert game_state.current_step > 0
    else:
        assert game_state.is_over()
    game_state.reset()
    assert game_state.game_score() == 0.0
    assert game_state.current_step == 0
    assert game_state.get_game_over_reason() is None
    grid_data = game_state.get_grid_data_np()
    playable_mask = ~grid_data["death"]
    assert not grid_data["occupied"][playable_mask].any()
    assert (grid_data["color_id"][playable_mask] == -1).all()
    shapes_after_reset = game_state.get_shapes()
    assert len(shapes_after_reset) == game_state.env_config.NUM_SHAPE_SLOTS
    if action is not None:
        assert initial_shapes_before_step != shapes_after_reset, (
            "Shapes did not change after reset and step"
        )
    is_over_after_reset = game_state.is_over()
    valid_actions_after_reset = game_state.valid_actions()
    if is_over_after_reset:
        assert not valid_actions_after_reset
        reason = game_state.get_game_over_reason()
        assert reason is not None and "start" in reason.lower()
    else:
        assert valid_actions_after_reset
        assert game_state.get_game_over_reason() is None


def test_game_state_step_valid(game_state: GameState) -> None:
    """Test a single valid step using the wrapper."""
    if game_state.is_over():
        pytest.skip("Cannot perform step test: game is over initially.")
    initial_score = game_state.game_score()
    initial_shape_count = count_non_none_shapes(game_state)
    initial_step = game_state.current_step
    action = get_first_valid_action(game_state)
    assert action is not None, "No valid action found for step test."
    logging.debug(
        f"Before step: Action={action}, Score={initial_score}, Step={initial_step}"
    )
    reward, done = game_state.step(action)
    logging.debug(
        f"After step: Reward={reward:.4f}, Done={done}, Score={game_state.game_score()}, Step={game_state.current_step}"
    )
    assert isinstance(reward, float)
    assert isinstance(done, bool)
    assert done == game_state.is_over()
    assert game_state.current_step == initial_step + 1
    current_shape_count = count_non_none_shapes(game_state)
    if initial_shape_count == 1 and not done:
        assert current_shape_count == game_state.env_config.NUM_SHAPE_SLOTS
    elif initial_shape_count > 1:
        assert current_shape_count == initial_shape_count - 1
    _ = game_state.get_grid_data_np()


def test_game_state_step_invalid_action(game_state: GameState) -> None:
    """Test stepping with an invalid action index."""
    invalid_action = -1
    initial_step = game_state.current_step
    initial_score = game_state.game_score()
    reward, done = game_state.step(invalid_action)
    assert done is True, "Game should be over after invalid step"
    assert game_state.is_over()
    # Check returned reward uses config penalty
    assert reward == game_state.env_config.PENALTY_GAME_OVER
    assert game_state.current_step == initial_step
    # Check internal score uses config penalty (as invalid action triggers game over)
    assert (
        game_state.game_score()
        == initial_score + game_state.env_config.PENALTY_GAME_OVER
    )
    reason = game_state.get_game_over_reason()
    assert reason is not None and "invalid action" in reason.lower()
    game_state.reset()
    action_dim = (
        game_state.env_config.NUM_SHAPE_SLOTS
        * game_state.env_config.ROWS
        * game_state.env_config.COLS
    )
    invalid_action_large = action_dim + 10
    reward, done = game_state.step(invalid_action_large)
    assert done is True
    assert reward == game_state.env_config.PENALTY_GAME_OVER


# Use the 4x4 grid fixture to make game over less likely after one step
def test_game_state_step_on_occupied_cell(game_state_4x4: GameState) -> None:
    """Test stepping to place a shape on an already occupied cell (using 4x4 grid)."""
    gs = game_state_4x4  # Use the 4x4 fixture
    if gs.is_over():
        pytest.skip("Initial 4x4 state is over.")

    # Find first valid action and place it
    action1 = get_first_valid_action(gs)
    if action1 is None:
        pytest.skip("No valid first action found in 4x4 grid.")

    # Decode action1 to find where it placed
    grid_size = gs.env_config.ROWS * gs.env_config.COLS
    shape1_idx = action1 // grid_size
    remainder1 = action1 % grid_size
    r1_base = remainder1 // gs.env_config.COLS
    c1_base = remainder1 % gs.env_config.COLS
    shape1 = gs.get_shapes()[shape1_idx]
    assert shape1 is not None
    # Get one specific coordinate occupied by the first shape
    dr0, dc0, _ = shape1.triangles[0]
    r_occupied, c_occupied = r1_base + dr0, c1_base + dc0

    # Perform the first step
    gs.step(action1)

    if gs.is_over():
        # It's still possible the game ends, especially if few actions remain
        pytest.skip("Game ended after the first step even on 4x4 grid.")

    # Try to place the *next* available shape targeting the occupied cell
    shapes_after_step1 = gs.get_shapes()
    action2 = -1
    target_shape_idx = -1

    # Find the first available shape slot after step 1
    for idx, shape in enumerate(shapes_after_step1):
        if shape is not None:
            target_shape_idx = idx
            break

    if target_shape_idx == -1:
        pytest.skip("No second shape available to test occupied placement.")

    # Encode an action for the target shape at the occupied coordinate
    action2 = encode_action(target_shape_idx, r_occupied, c_occupied, gs)

    # This action targeting an occupied cell should be invalid
    assert action2 not in gs.valid_actions(), (
        f"Action {action2} targeting occupied cell ({r_occupied},{c_occupied}) is unexpectedly valid."
    )

    # Attempting the invalid step
    initial_score = gs.game_score()
    reward, done = gs.step(action2)

    assert done is True, "Game should end after attempting to place on occupied cell"
    assert gs.is_over()
    assert reward == gs.env_config.PENALTY_GAME_OVER
    assert (
        gs.game_score() == initial_score + gs.env_config.PENALTY_GAME_OVER
    )  # Score updated with penalty
    reason = gs.get_game_over_reason()
    assert reason is not None and "invalid action" in reason.lower()


def test_game_state_is_over_logic(game_state: GameState) -> None:
    """Test the is_over condition by observing behavior."""
    max_steps = game_state.env_config.ROWS * game_state.env_config.COLS * 2
    steps = 0
    while not game_state.is_over() and steps < max_steps:
        action = get_first_valid_action(game_state)
        if action is None:
            break
        game_state.step(action)
        steps += 1
    if steps >= max_steps:
        pytest.skip("Game did not terminate naturally within step limit.")
    assert game_state.is_over()
    assert not game_state.valid_actions()
    assert game_state.get_game_over_reason() is not None
    game_state.reset()
    if not game_state.is_over():
        assert game_state.valid_actions()
        assert game_state.get_game_over_reason() is None
    else:
        assert not game_state.valid_actions()
        assert game_state.get_game_over_reason() is not None


def test_game_state_copy(game_state: GameState) -> None:
    """Test the copy method of the GameState wrapper."""
    if game_state.is_over():
        pytest.skip("Cannot test copy effectively on initial terminal state.")
    action1 = get_first_valid_action(game_state)
    if action1:
        game_state.step(action1)
    gs1 = game_state
    gs2 = gs1.copy()
    assert gs1.game_score() == gs2.game_score()
    assert gs1.env_config == gs2.env_config
    assert gs1.is_over() == gs2.is_over()
    assert gs1.get_game_over_reason() == gs2.get_game_over_reason()
    assert gs1.current_step == gs2.current_step
    assert gs1._cpp_state is not gs2._cpp_state
    shapes1 = gs1.get_shapes()
    shapes2 = gs2.get_shapes()
    assert shapes1 == shapes2
    grid1 = gs1.get_grid_data_np()
    grid2 = gs2.get_grid_data_np()
    assert np.array_equal(grid1["occupied"], grid2["occupied"])
    assert np.array_equal(grid1["color_id"], grid2["color_id"])
    assert np.array_equal(grid1["death"], grid2["death"])
    assert gs1.valid_actions() == gs2.valid_actions()
    action2 = get_first_valid_action(gs2)
    if not action2:
        assert not gs1.valid_actions()
        return
    score1_before_gs2_step = gs1.game_score()
    step1_before_gs2_step = gs1.current_step
    grid1_occupied_before_gs2_step = gs1.get_grid_data_np()["occupied"].copy()
    shapes1_before_gs2_step = gs1.get_shapes()
    reward2, done2 = gs2.step(action2)
    assert gs1.game_score() == score1_before_gs2_step
    assert gs1.current_step == step1_before_gs2_step
    assert np.array_equal(
        gs1.get_grid_data_np()["occupied"], grid1_occupied_before_gs2_step
    )
    assert gs1.get_shapes() == shapes1_before_gs2_step
    assert gs2.current_step == step1_before_gs2_step + 1
    assert gs2.game_score() != score1_before_gs2_step or reward2 == 0.0
    assert not np.array_equal(
        gs2.get_grid_data_np()["occupied"], grid1_occupied_before_gs2_step
    )
    assert gs2.get_shapes() != shapes1_before_gs2_step


def test_game_state_get_outcome(game_state: GameState) -> None:
    """Test get_outcome method."""
    # This test remains conceptual until get_outcome is implemented in C++ and exposed
    if game_state.is_over():
        pass
    else:
        pass


def test_game_state_debug_toggle(game_state_3x3: GameState) -> None:
    """Test the debug_toggle_cell method."""
    gs = game_state_3x3
    r, c = 1, 1
    grid_data_initial = gs.get_grid_data_np()
    if not (
        0 <= r < gs.env_config.ROWS
        and 0 <= c < gs.env_config.COLS
        and not grid_data_initial["death"][r, c]
    ):
        pytest.skip(f"Cell ({r},{c}) is invalid or death zone in 3x3 grid.")
    initial_occupied = grid_data_initial["occupied"][r, c]
    initial_color = grid_data_initial["color_id"][r, c]
    initial_score = gs.game_score()  # Get score before toggle
    gs.debug_toggle_cell(r, c)
    grid_data_after = gs.get_grid_data_np()
    assert grid_data_after["occupied"][r, c] == (not initial_occupied)
    if not initial_occupied:
        assert grid_data_after["color_id"][r, c] == -2  # DEBUG_COLOR_ID
    else:
        assert grid_data_after["color_id"][r, c] == -1  # NO_COLOR_ID
    assert gs.game_score() == initial_score, "Score should not change on debug toggle"
    _ = gs.valid_actions()
    gs.debug_toggle_cell(r, c)
    grid_data_final = gs.get_grid_data_np()
    assert grid_data_final["occupied"][r, c] == initial_occupied
    assert grid_data_final["color_id"][r, c] == initial_color
    assert gs.game_score() == initial_score, "Score should still be unchanged"


# --- Score Verification Tests ---


def test_reward_placement_only(game_state: GameState) -> None:
    """Verify RETURNED REWARD for placing triangles without clearing lines."""
    if game_state.is_over():
        pytest.skip("Game over initially.")

    initial_score = game_state.game_score()
    action = get_first_valid_action(game_state)
    if action is None:
        pytest.skip("No valid actions.")

    shapes = game_state.get_shapes()
    grid_size = game_state.env_config.ROWS * game_state.env_config.COLS
    shape_idx = action // grid_size
    shape_placed = shapes[shape_idx]
    assert shape_placed is not None
    num_triangles_placed = len(shape_placed.triangles)

    reward, done = game_state.step(action)

    # Calculate expected reward based *only* on placement and step alive/penalty
    expected_reward = (
        num_triangles_placed * game_state.env_config.REWARD_PER_PLACED_TRIANGLE
    )
    if done:
        expected_reward += game_state.env_config.PENALTY_GAME_OVER
    else:
        expected_reward += game_state.env_config.REWARD_PER_STEP_ALIVE

    assert reward == pytest.approx(expected_reward)
    expected_score = initial_score + reward
    assert game_state.game_score() == pytest.approx(expected_score)


def test_reward_line_clear(
    game_state_3x3: GameState, single_up_triangle_shape: Shape
) -> None:
    """Verify RETURNED REWARD increases correctly when clearing lines."""
    gs = game_state_3x3
    # Setup: Place two triangles manually, leaving one spot to complete a line (e.g., row 0)
    gs.debug_toggle_cell(0, 0)  # Occupy (0,0) - Down
    gs.debug_toggle_cell(0, 2)  # Occupy (0,2) - Down
    # Cell (0,1) is Up and is the target

    # Force the required shape into slot 0
    gs.debug_set_shapes([single_up_triangle_shape, None, None])

    initial_score = gs.game_score()  # Should be 0 after setup via debug

    # Action to place the shape from slot 0 at (0,1)
    target_action = encode_action(0, 0, 1, gs)

    if target_action == -1 or target_action not in gs.valid_actions():
        pytest.fail("Action to place forced shape at (0,1) is invalid.")

    # Execute the step that clears the line
    reward, done = gs.step(target_action)

    # Expected reward calculation based on config
    tris_placed = len(single_up_triangle_shape.triangles)  # Should be 1
    tris_cleared = 3  # cells 0,0; 0,1; 0,2 are cleared
    expected_reward = (
        tris_placed * gs.env_config.REWARD_PER_PLACED_TRIANGLE
        + tris_cleared * gs.env_config.REWARD_PER_CLEARED_TRIANGLE
    )
    if done:
        expected_reward += gs.env_config.PENALTY_GAME_OVER
    else:
        expected_reward += gs.env_config.REWARD_PER_STEP_ALIVE

    # Verify the returned reward matches the calculation
    assert reward == pytest.approx(expected_reward)

    # Verify the final score is initial_score + calculated reward
    expected_score = initial_score + reward
    assert gs.game_score() == pytest.approx(expected_score)


def test_internal_score_placement(game_state: GameState) -> None:
    """Verify INTERNAL score increases by +1 per triangle placed (no line clear)."""
    if game_state.is_over():
        pytest.skip("Game over initially.")

    game_state.game_score()
    action = get_first_valid_action(game_state)
    if action is None:
        pytest.skip("No valid actions.")

    shapes = game_state.get_shapes()
    grid_size = game_state.env_config.ROWS * game_state.env_config.COLS
    shape_idx = action // grid_size
    shape_placed = shapes[shape_idx]
    assert shape_placed is not None
    len(shape_placed.triangles)

    # Store score *before* step
    score_before = game_state.game_score()
    reward, done = game_state.step(action)
    score_after = game_state.game_score()

    # Expected internal score increase = +1 per placed triangle
    # The reward returned by step() includes scaling factors and penalties/bonuses
    # The internal score_ should reflect the raw +1/+2 logic plus the reward components
    # expected_internal_increase = float(num_triangles_placed) # This is NOT how score is updated

    # Check that the score difference matches the returned reward
    assert score_after - score_before == pytest.approx(reward)


def test_internal_score_line_clear(
    game_state_3x3: GameState, single_up_triangle_shape: Shape
) -> None:
    """Verify INTERNAL score increases correctly (+1 per placed, +2 per cleared)."""
    gs = game_state_3x3
    gs.debug_toggle_cell(0, 0)
    gs.debug_toggle_cell(0, 2)
    gs.debug_set_shapes([single_up_triangle_shape, None, None])
    gs.game_score()

    target_action = encode_action(0, 0, 1, gs)
    if target_action == -1 or target_action not in gs.valid_actions():
        pytest.fail("Action to place forced shape at (0,1) is invalid.")

    score_before = gs.game_score()
    reward, done = gs.step(target_action)
    score_after = gs.game_score()

    # tris_placed = 1
    # tris_cleared = 3
    # Expected internal score increase = +1 * tris_placed + +2 * tris_cleared
    # expected_internal_increase = float(1 * 1 + 3 * 2) # This is NOT how score is updated

    # Check that the score difference matches the returned reward
    assert score_after - score_before == pytest.approx(reward)


File: tests/utils/__init__.py


File: tests/utils/test_geometry.py
# File: tests/utils/test_geometry.py

from trianglengin.utils import geometry


def test_is_point_in_polygon_square() -> None:
    """Test point in polygon for a simple square."""
    # Explicitly type as list of float tuples
    square: list[tuple[float, float]] = [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)]
    assert geometry.is_point_in_polygon((0.5, 0.5), square)
    assert geometry.is_point_in_polygon((0.5, 0.0), square)
    assert geometry.is_point_in_polygon((1.0, 0.5), square)
    assert geometry.is_point_in_polygon((0.5, 1.0), square)
    assert geometry.is_point_in_polygon((0.0, 0.5), square)
    assert geometry.is_point_in_polygon((0.0, 0.0), square)
    assert geometry.is_point_in_polygon((1.0, 1.0), square)
    assert geometry.is_point_in_polygon((1.0, 0.0), square)
    assert geometry.is_point_in_polygon((0.0, 1.0), square)
    assert not geometry.is_point_in_polygon((1.5, 0.5), square)
    assert not geometry.is_point_in_polygon((0.5, -0.5), square)
    assert not geometry.is_point_in_polygon((-0.1, 0.1), square)
    assert not geometry.is_point_in_polygon((0.5, 1.1), square)


def test_is_point_in_polygon_triangle() -> None:
    """Test point in polygon for a triangle."""
    triangle: list[tuple[float, float]] = [(0.0, 0.0), (2.0, 0.0), (1.0, 2.0)]
    assert geometry.is_point_in_polygon((1.0, 0.5), triangle)
    assert geometry.is_point_in_polygon((1.0, 1.0), triangle)
    assert geometry.is_point_in_polygon((1.0, 0.0), triangle)
    assert geometry.is_point_in_polygon((0.5, 1.0), triangle)
    assert geometry.is_point_in_polygon((1.5, 1.0), triangle)
    assert geometry.is_point_in_polygon((0.0, 0.0), triangle)
    assert geometry.is_point_in_polygon((2.0, 0.0), triangle)
    assert geometry.is_point_in_polygon((1.0, 2.0), triangle)
    assert not geometry.is_point_in_polygon((1.0, 2.1), triangle)
    assert not geometry.is_point_in_polygon((3.0, 0.5), triangle)
    assert not geometry.is_point_in_polygon((-0.5, 0.5), triangle)
    assert not geometry.is_point_in_polygon((1.0, -0.1), triangle)


def test_is_point_in_polygon_concave() -> None:
    """Test point in polygon for a concave shape (e.g., Pacman)."""
    # Cast int tuples to float tuples for the test data
    concave: list[tuple[float, float]] = [
        (float(x), float(y))
        for x, y in [(0, 0), (3, 0), (3, 1), (1, 1), (1, 2), (2, 2), (2, 3), (0, 3)]
    ]
    assert geometry.is_point_in_polygon((0.5, 0.5), concave)
    assert geometry.is_point_in_polygon((2.5, 0.5), concave)
    assert geometry.is_point_in_polygon((0.5, 2.5), concave)
    assert geometry.is_point_in_polygon((1.5, 2.5), concave)
    assert not geometry.is_point_in_polygon((1.5, 1.5), concave)
    assert not geometry.is_point_in_polygon((4.0, 1.0), concave)
    assert not geometry.is_point_in_polygon((1.0, 4.0), concave)
    assert geometry.is_point_in_polygon((1.5, 0.0), concave)
    assert geometry.is_point_in_polygon((1.0, 1.5), concave)
    assert geometry.is_point_in_polygon((1.5, 1.0), concave)
    assert geometry.is_point_in_polygon((2.0, 2.5), concave)
    assert geometry.is_point_in_polygon((0.0, 1.5), concave)
    assert geometry.is_point_in_polygon((1.0, 1.0), concave)
    assert geometry.is_point_in_polygon((1.0, 2.0), concave)
    assert geometry.is_point_in_polygon((3.0, 0.0), concave)
    assert geometry.is_point_in_polygon((0.0, 3.0), concave)


File: src/trianglengin/__init__.py
# Core engine exports
from .config import EnvConfig
from .game_interface import (
    GameState,
    Shape,
)
from .utils import ActionType, geometry

__all__ = [
    # Core Interface & Config
    "GameState",
    "Shape",
    "EnvConfig",
    # Utilities & Types
    "utils",
    "geometry",
    "ActionType",
]

# Attempt to import the C++ module to make its version accessible (optional)
try:
    from . import trianglengin_cpp as _cpp_module

    __version__ = _cpp_module.__version__
except ImportError:
    # If C++ module not found (e.g., during docs build without compilation)
    # Try getting version from package metadata if installed
    try:
        from importlib.metadata import version

        __version__ = version("trianglengin")
    except ImportError:
        __version__ = "unknown"  # Fallback
    except Exception:
        __version__ = "unknown (C++ module not found, package metadata failed)"


File: src/trianglengin/py.typed


File: src/trianglengin/game_interface.py
# File: src/trianglengin/game_interface.py
import logging
import random
from typing import Any, cast  # Import necessary types

import numpy as np

from .config import EnvConfig

try:
    # Keep the alias for clarity within this file
    import trianglengin.trianglengin_cpp as cpp_module
except ImportError as e:
    raise ImportError(
        "Trianglengin C++ extension module ('trianglengin.trianglengin_cpp') not found. "
        "Ensure the package was built correctly (`pip install -e .`). "
        f"Original error: {e}"
    ) from e


class Shape:
    """Python representation of a shape's data returned from C++."""

    def __init__(
        self,
        triangles: list[tuple[int, int, bool]],
        color: tuple[int, int, int],
        color_id: int,
    ):
        # Sort triangles for consistent representation and hashing
        self.triangles: list[tuple[int, int, bool]] = sorted(triangles)
        self.color: tuple[int, int, int] = color
        self.color_id: int = color_id

    def bbox(self) -> tuple[int, int, int, int]:
        """Calculates bounding box (min_r, min_c, max_r, max_c) in relative coords."""
        if not self.triangles:
            return (0, 0, 0, 0)
        rows = [t[0] for t in self.triangles]
        cols = [t[1] for t in self.triangles]
        return (min(rows), min(cols), max(rows), max(cols))

    def copy(self) -> "Shape":
        """Creates a shallow copy."""
        # Use sorted triangles in the copy as well
        return Shape(list(self.triangles), self.color, self.color_id)

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Shape):
            return NotImplemented
        # Comparison relies on sorted triangles
        return (
            self.triangles == other.triangles
            and self.color == other.color
            and self.color_id == other.color_id
        )

    def __hash__(self) -> int:
        # Hash relies on sorted triangles (converted to tuple)
        return hash((tuple(self.triangles), self.color, self.color_id))

    def __str__(self) -> str:
        return f"Shape(ColorID:{self.color_id}, Tris:{len(self.triangles)})"

    def to_cpp_repr(
        self,
    ) -> tuple[list[tuple[int, int, bool]], tuple[int, int, int], int]:
        """Converts this Python Shape object to the tuple format expected by C++ bindings."""
        return self.triangles, self.color, self.color_id


log = logging.getLogger(__name__)


class GameState:
    """
    Python wrapper for the C++ GameState implementation.
    Provides a Pythonic interface to the core game logic.
    """

    _cpp_state: cpp_module.GameStateCpp  # Add type hint for instance variable

    def __init__(
        self, config: EnvConfig | None = None, initial_seed: int | None = None
    ):
        self.env_config: EnvConfig = config if config else EnvConfig()
        used_seed = (
            initial_seed if initial_seed is not None else random.randint(0, 2**32 - 1)
        )
        try:
            # Pass the EnvConfig object directly to the C++ constructor binding
            self._cpp_state = cpp_module.GameStateCpp(self.env_config, used_seed)
        except Exception as e:
            log.exception(f"Failed to initialize C++ GameStateCpp: {e}")
            raise
        self._cached_shapes: list[Shape | None] | None = None
        self._cached_grid_data: dict[str, np.ndarray] | None = None

    def reset(self) -> None:
        """Resets the game to an initial state."""
        self._cpp_state.reset()
        self._clear_caches()
        log.debug("Python GameState wrapper reset.")

    def step(self, action: int) -> tuple[float, bool]:
        """
        Performs one game step based on the chosen action index.
        Returns: (reward, done)
        """
        try:
            # The C++ method already returns tuple[double, bool], cast might be redundant
            # if pybind handles it, but explicit cast helps mypy if stub is missing details.
            reward, done = cast("tuple[float, bool]", self._cpp_state.step(action))
            self._clear_caches()
            return reward, done
        except Exception as e:
            log.exception(f"Error during C++ step execution for action {action}: {e}")
            # Return penalty and done=True consistent with C++ logic for errors during step
            return self.env_config.PENALTY_GAME_OVER, True

    def is_over(self) -> bool:
        """Checks if the game is over."""
        # C++ returns bool, cast might be redundant but safe for mypy
        return cast("bool", self._cpp_state.is_over())

    def game_score(self) -> float:
        """Returns the current accumulated score."""
        # C++ returns double, cast might be redundant but safe for mypy
        return cast("float", self._cpp_state.get_score())

    def get_outcome(self) -> float:
        """
        Returns the final outcome of the game if it's over, otherwise 0.0.
        Required by MCTS implementations like trimcts.
        """
        if self.is_over():
            # In this game, the final score is the outcome.
            # Adjust if a different outcome definition is needed (e.g., +1 win, -1 loss).
            return self.game_score()
        else:
            # MCTS typically expects 0 for non-terminal states during simulation.
            return 0.0

    def valid_actions(self, force_recalculate: bool = False) -> set[int]:
        """
        Returns a set of valid encoded action indices for the current state.
        """
        # C++ returns std::set<int>, pybind converts to Python set. Cast is safe.
        return cast(
            "set[int]", set(self._cpp_state.get_valid_actions(force_recalculate))
        )

    def get_shapes(self) -> list[Shape | None]:
        """Returns the list of current shapes in the preview slots."""
        if self._cached_shapes is None:
            # C++ returns list[Optional[tuple[list[tuple], tuple, int]]]
            shapes_data = self._cpp_state.get_shapes_cpp()
            self._cached_shapes = []
            for data in shapes_data:
                if data is None:
                    self._cached_shapes.append(None)
                else:
                    # Explicitly cast the structure returned by pybind if needed
                    tris_py, color_py, id_py = cast(
                        "tuple[list[tuple[int, int, bool]], tuple[int, int, int], int]",
                        data,
                    )
                    self._cached_shapes.append(Shape(tris_py, color_py, id_py))
        return self._cached_shapes

    def get_grid_data_np(self) -> dict[str, np.ndarray]:
        """
        Returns the grid state (occupied, colors, death) as NumPy arrays.
        Uses cached data if available.
        """
        if self._cached_grid_data is None:
            # pybind numpy bindings should return np.ndarray directly
            occupied_np = self._cpp_state.get_grid_occupied_flat()
            color_id_np = self._cpp_state.get_grid_colors_flat()
            death_np = self._cpp_state.get_grid_death_flat()
            self._cached_grid_data = {
                "occupied": occupied_np,
                "color_id": color_id_np,
                "death": death_np,
            }
        return self._cached_grid_data

    @property
    def current_step(self) -> int:
        """Returns the current step count."""
        return cast("int", self._cpp_state.get_current_step())

    def get_game_over_reason(self) -> str | None:
        """Returns the reason why the game ended, if it's over."""
        return cast("str | None", self._cpp_state.get_game_over_reason())

    def copy(self) -> "GameState":
        """Creates a deep copy of the game state."""
        new_wrapper = GameState.__new__(GameState)
        new_wrapper.env_config = self.env_config
        new_wrapper._cpp_state = self._cpp_state.copy()  # C++ copy handles members
        new_wrapper._cached_shapes = None
        new_wrapper._cached_grid_data = None
        return new_wrapper

    def debug_toggle_cell(self, r: int, c: int) -> None:
        """Toggles the state of a cell via the C++ implementation."""
        self._cpp_state.debug_toggle_cell(r, c)
        self._clear_caches()

    def debug_set_shapes(self, shapes: list[Shape | None]) -> None:
        """
        Directly sets the shapes in the preview slots. For debugging/testing.
        """
        # Convert Python Shape objects (or None) to the tuple format expected by C++ binding
        shapes_data = [s.to_cpp_repr() if s else None for s in shapes]
        self._cpp_state.debug_set_shapes(shapes_data)
        self._clear_caches()  # Invalidate caches after changing shapes

    def _clear_caches(self) -> None:
        """Clears Python-level caches."""
        self._cached_shapes = None
        self._cached_grid_data = None

    def __str__(self) -> str:
        shapes_repr = [str(s) if s else "None" for s in self.get_shapes()]
        status = "Over" if self.is_over() else "Ongoing"
        return (
            f"GameState(Step:{self.current_step}, Score:{self.game_score():.1f}, "
            f"Status:{status}, Shapes:[{', '.join(shapes_repr)}])"
        )

    @property
    def cpp_state(self) -> Any:
        """Returns the underlying C++ GameState object."""
        return self._cpp_state


File: src/trianglengin/ui/config.py
# src/trianglengin/ui/config.py
"""
Configuration specific to display and visualization settings for the UI.
"""

import pygame  # Direct import
from pydantic import BaseModel, Field

# Initialize Pygame font module if not already done (safe to call multiple times)
pygame.font.init()

# Define a placeholder font loading function or load directly here
# In a real app, this might load from files or use system fonts more robustly.
try:
    DEBUG_FONT_DEFAULT = pygame.font.SysFont("monospace", 12)
except Exception:
    DEBUG_FONT_DEFAULT = pygame.font.Font(None, 15)  # Fallback default pygame font


class DisplayConfig(BaseModel):
    """Configuration for visualization display settings."""

    # Screen and Layout
    SCREEN_WIDTH: int = Field(default=1024, gt=0)
    SCREEN_HEIGHT: int = Field(default=768, gt=0)
    FPS: int = Field(default=60, gt=0)
    PADDING: int = Field(default=10, ge=0)
    HUD_HEIGHT: int = Field(default=30, ge=0)
    PREVIEW_AREA_WIDTH: int = Field(default=150, ge=50)
    PREVIEW_PADDING: int = Field(default=5, ge=0)
    PREVIEW_INNER_PADDING: int = Field(default=3, ge=0)
    PREVIEW_BORDER_WIDTH: int = Field(default=1, ge=0)
    PREVIEW_SELECTED_BORDER_WIDTH: int = Field(default=3, ge=0)

    # Fonts
    # Use default=None and validate/load later if pygame is available
    DEBUG_FONT: pygame.font.Font | None = Field(default=DEBUG_FONT_DEFAULT)

    class Config:
        arbitrary_types_allowed = True  # Allow pygame.font.Font


# Optional: Create a default instance for easy import elsewhere
DEFAULT_DISPLAY_CONFIG = DisplayConfig()


File: src/trianglengin/ui/__init__.py
# src/trianglengin/ui/__init__.py
"""
UI components for the Triangle Engine, including interactive modes
and visualization. Requires 'pygame' and 'typer'.
"""

# Directly import the components. Dependencies are now required.
from .app import Application
from .cli import app as cli_app
from .config import DEFAULT_DISPLAY_CONFIG, DisplayConfig
from .interaction import InputHandler
from .visualization import Visualizer

__all__ = [
    "Application",
    "cli_app",
    "DisplayConfig",
    "DEFAULT_DISPLAY_CONFIG",
    "InputHandler",
    "Visualizer",
]


File: src/trianglengin/ui/README.md


# UI Module (`trianglengin.ui`)

## Purpose

This module provides components for interacting with and visualizing the `trianglengin` game engine using Pygame and Typer. It is included as part of the main package installation.

## Components

-   **[`config.py`](config.py):** Defines `DisplayConfig` for UI-specific settings (screen size, FPS, fonts, colors).
-   **[`visualization/`](visualization/README.md):** Contains the `Visualizer` class and drawing functions responsible for rendering the game state using Pygame.
-   **[`interaction/`](interaction/README.md):** Contains the `InputHandler` class and helper functions to process keyboard/mouse input for interactive modes.
-   **[`app.py`](app.py):** The `Application` class integrates the `GameState` (from the core engine), `Visualizer`, and `InputHandler` to run the interactive application loop.
-   **[`cli.py`](cli.py):** Defines the command-line interface using Typer, providing the `trianglengin play` and `trianglengin debug` commands.

## Usage

After installing the `trianglengin` package (`pip install trianglengin`), you can run the interactive commands:

```bash
trianglengin play
trianglengin debug --seed 123
```

## Dependencies

-   **`trianglengin` (core):** Uses `GameState`, `EnvConfig`, `Shape`.
-   **`pygame`**: Required dependency for graphics, event handling, fonts.
-   **`typer`**: Required dependency for the command-line interface.
-   **Standard Libraries:** `typing`, `logging`, `sys`, `random`.

---

**Note:** While included, these UI components are designed to be initialized only when running the specific CLI commands (`play`, `debug`) and should not interfere with using the core `trianglengin` library for simulations.


File: src/trianglengin/ui/cli.py
# File: src/trianglengin/ui/cli.py
import logging
import random
import sys
from typing import Annotated

import numpy as np
import typer  # Now a required dependency

# Use absolute imports from core engine
from trianglengin.config import EnvConfig

# Import Application directly
from trianglengin.ui.app import Application

app = typer.Typer(
    name="trianglengin",
    help="Core Triangle Engine - Interactive Modes.",
    add_completion=False,
)

LogLevelOption = Annotated[
    str,
    typer.Option(
        "--log-level",
        "-l",
        help="Set the logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL).",
        case_sensitive=False,
    ),
]

SeedOption = Annotated[
    int,
    typer.Option(
        "--seed",
        "-s",
        help="Random seed for C++ engine initialization.",
    ),
]


def setup_logging(log_level_str: str) -> None:
    """Configures root logger based on string level."""
    log_level_str = log_level_str.upper()
    log_level_map = {
        "DEBUG": logging.DEBUG,
        "INFO": logging.INFO,
        "WARNING": logging.WARNING,
        "ERROR": logging.ERROR,
        "CRITICAL": logging.CRITICAL,
    }
    log_level = log_level_map.get(log_level_str, logging.INFO)
    logging.basicConfig(
        level=log_level,
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
        handlers=[logging.StreamHandler(sys.stdout)],
        force=True,
    )
    # Set pygame log level (pygame is now a required dependency)

    logging.getLogger("pygame").setLevel(logging.WARNING)
    logging.info(f"Root logger level set to {logging.getLevelName(log_level)}")


def run_interactive_mode(mode: str, seed: int, log_level: str) -> None:
    """Runs the interactive application."""
    setup_logging(log_level)
    logger = logging.getLogger(__name__)
    logger.info(f"Running Triangle Engine in {mode.capitalize()} mode...")

    # --- Seeding ---
    try:
        random.seed(seed)
        # Use modern NumPy seeding
        np.random.default_rng(seed)
        logger.info(
            f"Set Python random seed to {seed}. NumPy RNG initialized. C++ engine seeded separately."
        )
    except Exception as e:
        logger.error(f"Error setting Python/NumPy seeds: {e}")
    # --- End Seeding ---

    try:
        # Validate core EnvConfig
        _ = EnvConfig()
        logger.info("EnvConfig validated.")
    except Exception as e:
        logger.critical(f"EnvConfig validation failed: {e}", exc_info=True)
        sys.exit(1)

    try:
        # Application is part of the UI package
        app_instance = Application(mode=mode)
        app_instance.run()
    # Keep general exception handling
    except Exception as e:
        logger.critical(f"An unhandled error occurred: {e}", exc_info=True)
        sys.exit(1)

    logger.info("Exiting.")
    sys.exit(0)


@app.command()
def play(
    log_level: LogLevelOption = "INFO",
    seed: SeedOption = 42,
) -> None:
    """Run the game in interactive Play mode."""
    run_interactive_mode(mode="play", seed=seed, log_level=log_level)


@app.command()
def debug(
    log_level: LogLevelOption = "DEBUG",
    seed: SeedOption = 42,
) -> None:
    """Run the game in interactive Debug mode."""
    run_interactive_mode(mode="debug", seed=seed, log_level=log_level)


if __name__ == "__main__":
    app()


File: src/trianglengin/ui/app.py
# File: src/trianglengin/ui/app.py
import logging

# UI imports are now direct as dependencies are required
import pygame

# Use absolute imports from core engine
from trianglengin.config import EnvConfig
from trianglengin.game_interface import GameState
from trianglengin.ui import config as ui_config
from trianglengin.ui import interaction, visualization

logger = logging.getLogger(__name__)


class Application:
    """Main application integrating visualization and interaction for trianglengin."""

    def __init__(self, mode: str = "play") -> None:
        self.display_config = ui_config.DisplayConfig()  # Use UI config
        self.env_config = EnvConfig()  # Use core EnvConfig
        self.mode = mode

        pygame.init()
        pygame.font.init()
        self.screen = self._setup_screen()
        self.clock = pygame.time.Clock()
        self.fonts = visualization.load_fonts()  # From ui.visualization

        if self.mode in ["play", "debug"]:
            # GameState comes from the core engine
            self.game_state = GameState(self.env_config)
            # Visualizer and InputHandler come from the UI package
            self.visualizer = visualization.Visualizer(
                self.screen,
                self.display_config,
                self.env_config,
                self.fonts,
            )
            self.input_handler = interaction.InputHandler(
                self.game_state, self.visualizer, self.mode, self.env_config
            )
        else:
            logger.error(f"Unsupported application mode: {self.mode}")
            raise ValueError(f"Unsupported application mode: {self.mode}")

        self.running = True

    def _setup_screen(self) -> pygame.Surface:
        """Initializes the Pygame screen."""
        screen = pygame.display.set_mode(
            (
                self.display_config.SCREEN_WIDTH,
                self.display_config.SCREEN_HEIGHT,
            ),
            pygame.RESIZABLE,
        )
        pygame.display.set_caption(f"Triangle Engine - {self.mode.capitalize()} Mode")
        return screen

    def run(self) -> None:
        """Main application loop."""
        logger.info(f"Starting application in {self.mode} mode.")
        while self.running:
            self.clock.tick(self.display_config.FPS)

            if self.input_handler:
                self.running = self.input_handler.handle_input()
                if not self.running:
                    break
            else:
                # Basic event handling if input_handler fails (shouldn't happen)
                for event in pygame.event.get():
                    if event.type == pygame.QUIT:
                        self.running = False
                    if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                        self.running = False
                    if event.type == pygame.VIDEORESIZE and self.visualizer:
                        try:
                            w, h = max(320, event.w), max(240, event.h)
                            self.visualizer.screen = pygame.display.set_mode(
                                (w, h), pygame.RESIZABLE
                            )
                            self.visualizer.layout_rects = None
                        except pygame.error as e:
                            logger.error(f"Error resizing window: {e}")
                if not self.running:
                    break

            if (
                self.mode in ["play", "debug"]
                and self.visualizer
                and self.game_state
                and self.input_handler
            ):
                interaction_render_state = (
                    self.input_handler.get_render_interaction_state()
                )
                self.visualizer.render(
                    self.game_state,
                    self.mode,
                    **interaction_render_state,
                )
                pygame.display.flip()

        logger.info("Application loop finished.")
        pygame.quit()


File: src/trianglengin/ui/visualization/__init__.py
"""
Visualization module for rendering the game state using Pygame.
Provides components for interactive play/debug modes.
"""

# Imports are now direct. If pygame is missing, errors will occur upon use.

# Import core components needed externally
# Import core EnvConfig for type hinting if needed
# from trianglengin.config import EnvConfig # REMOVED Re-export
# from ..config import DisplayConfig  # REMOVED Re-export

from .core import colors  # Import the colors module
from .core.coord_mapper import (  # Import specific functions
    get_grid_coords_from_screen,
    get_preview_index_from_screen,
)
from .core.fonts import load_fonts  # Import specific function
from .core.visualizer import Visualizer  # Import the class

# Import drawing functions directly
from .drawing.grid import (
    draw_debug_grid_overlay,
    draw_grid_background,
    draw_grid_state,
)
from .drawing.highlight import draw_debug_highlight
from .drawing.hud import render_hud
from .drawing.previews import (
    draw_floating_preview,
    draw_placement_preview,
    render_previews,
)
from .drawing.shapes import draw_shape
from .drawing.utils import get_triangle_points

__all__ = [
    # Core Renderer & Layout related
    "Visualizer",
    "load_fonts",
    "colors",  # Export the colors module
    "get_grid_coords_from_screen",
    "get_preview_index_from_screen",
    # Drawing Functions
    "draw_grid_background",
    "draw_grid_state",
    "draw_debug_grid_overlay",
    "draw_shape",
    "render_previews",
    "draw_placement_preview",
    "draw_floating_preview",
    "render_hud",
    "draw_debug_highlight",
    "get_triangle_points",
    # Configs are NOT re-exported here
    # "DisplayConfig",
    # "EnvConfig",
]


File: src/trianglengin/ui/visualization/README.md

# UI Visualization Module (`trianglengin.ui.visualization`)

**Requires:** `pygame`

## Purpose and Architecture

This module is responsible for rendering the game state visually using the Pygame library, specifically for the **interactive modes** (play/debug) provided by the `trianglengin.ui` package.

-   **Core Components ([`core/README.md`](core/README.md)):**
    -   `Visualizer`: Orchestrates the rendering process for interactive modes.
    -   `layout`: Calculates the screen positions and sizes for different UI areas.
    -   `fonts`: Loads necessary font files.
    -   `colors`: Defines a centralized palette of RGB color tuples.
    -   `coord_mapper`: Provides functions to map screen coordinates to grid coordinates and preview indices.
-   **Drawing Components ([`drawing/README.md`](drawing/README.md)):**
    -   Contains specific functions for drawing different elements onto Pygame surfaces (grid, shapes, previews, HUD, highlights).

**Note:** This module depends on the core `trianglengin` engine for game state data (`GameState`, `EnvConfig`, `Shape`).

## Exposed Interfaces

-   **Core Classes & Functions:**
    -   `Visualizer`: Main renderer for interactive modes.
    -   `load_fonts`: Loads Pygame fonts.
    -   `colors`: Module containing color constants (e.g., `colors.WHITE`).
    -   `get_grid_coords_from_screen`: Maps screen to grid coordinates.
    -   `get_preview_index_from_screen`: Maps screen to preview index.
-   **Drawing Functions:** (Exposed via `trianglengin.ui.visualization.drawing`)
-   **Config:** (Configs are *not* re-exported from this module)

## Dependencies

-   **`trianglengin` (core):** `GameState`, `EnvConfig`, `Shape`.
-   **`trianglengin.ui.config`**: `DisplayConfig`.
-   **`trianglengin.utils`**: `geometry`.
-   **`pygame`**: The core library used for all drawing, surface manipulation, and font rendering.
-   **Standard Libraries:** `typing`, `logging`, `math`.

---

**Note:** Please keep this README updated when changing rendering logic, adding new visual elements, modifying layout calculations, or altering the interfaces exposed.


File: src/trianglengin/ui/visualization/drawing/grid.py
import logging

import numpy as np

# Guard UI imports
try:
    import pygame

    from ..core import colors  # Relative import
    from .utils import get_triangle_points  # Relative import
except ImportError as e:
    raise ImportError(
        "UI components require 'pygame'. Install with 'pip install trianglengin[ui]'."
    ) from e

# Use absolute imports for core components
from trianglengin.config import EnvConfig

# Import DisplayConfig from the correct UI location
from trianglengin.ui.config import DisplayConfig

log = logging.getLogger(__name__)


def draw_grid_background(
    surface: pygame.Surface,
    env_config: EnvConfig,  # Core config
    display_config: DisplayConfig,  # UI config
    cw: float,
    ch: float,
    ox: float,
    oy: float,
    game_over: bool = False,
    debug_mode: bool = False,
    death_mask_np: np.ndarray | None = None,
) -> None:
    """Draws the background grid structure using pre-calculated render parameters."""
    bg_color = colors.GRID_BG_GAME_OVER if game_over else colors.GRID_BG_DEFAULT
    surface.fill(bg_color)

    if cw <= 0 or ch <= 0:
        log.warning("Cannot draw grid background with zero cell dimensions.")
        return

    rows, cols = env_config.ROWS, env_config.COLS
    if death_mask_np is None or death_mask_np.shape != (rows, cols):
        log.warning(
            "Death mask not provided or shape mismatch, cannot draw death zones accurately."
        )
        # Attempt to reconstruct death mask from config if not provided
        death_mask_np = np.full((rows, cols), True, dtype=bool)
        for r_idx in range(rows):
            if r_idx < len(env_config.PLAYABLE_RANGE_PER_ROW):
                start_c, end_c = env_config.PLAYABLE_RANGE_PER_ROW[r_idx]
                if start_c < end_c:
                    death_mask_np[r_idx, start_c:end_c] = False
            else:
                log.warning(f"Missing playable range definition for row {r_idx}")

    for r in range(rows):
        for c in range(cols):
            is_up = (r + c) % 2 != 0
            is_death = death_mask_np[r, c]

            if is_death:
                cell_color = colors.DEATH_ZONE_COLOR
            else:
                # Alternate background color based on checkerboard pattern
                cell_color = (
                    colors.GRID_BG_LIGHT if (r % 2 == c % 2) else colors.GRID_BG_DARK
                )

            points = get_triangle_points(r, c, is_up, ox, oy, cw, ch)
            pygame.draw.polygon(surface, cell_color, points)
            pygame.draw.polygon(surface, colors.GRID_LINE_COLOR, points, 1)

            # Draw debug coordinates if in debug mode and font is available
            if debug_mode:
                debug_font = display_config.DEBUG_FONT
                if debug_font:
                    text = f"{r},{c}"
                    text_surf = debug_font.render(text, True, colors.DEBUG_TOGGLE_COLOR)
                    center_x = sum(p[0] for p in points) / 3
                    center_y = sum(p[1] for p in points) / 3
                    text_rect = text_surf.get_rect(center=(center_x, center_y))
                    surface.blit(text_surf, text_rect)


def draw_grid_state(
    surface: pygame.Surface,
    occupied_np: np.ndarray,
    color_id_np: np.ndarray,
    death_np: np.ndarray,
    rows: int,
    cols: int,
    cw: float,
    ch: float,
    ox: float,
    oy: float,
) -> None:
    """Draws the occupied triangles with their colors using pre-calculated parameters."""
    if cw <= 0 or ch <= 0:
        log.warning("Cannot draw grid state with zero cell dimensions.")
        return

    if (
        occupied_np.shape != (rows, cols)
        or color_id_np.shape != (rows, cols)
        or death_np.shape != (rows, cols)
    ):
        log.error("Grid state array shape mismatch.")
        return

    for r in range(rows):
        for c in range(cols):
            if death_np[r, c]:
                continue  # Skip death zones

            if occupied_np[r, c]:
                color_id = int(color_id_np[r, c])
                color = colors.ID_TO_COLOR_MAP.get(color_id)
                is_up = (r + c) % 2 != 0
                points = get_triangle_points(r, c, is_up, ox, oy, cw, ch)

                if color is not None:
                    pygame.draw.polygon(surface, color, points)
                elif color_id == colors.DEBUG_COLOR_ID:
                    # Draw debug-toggled cells with a specific color
                    pygame.draw.polygon(surface, colors.DEBUG_TOGGLE_COLOR, points)
                else:
                    # Fallback for unexpected color IDs
                    log.warning(
                        f"Occupied cell ({r},{c}) has invalid color ID: {color_id}"
                    )
                    pygame.draw.polygon(surface, colors.TRIANGLE_EMPTY_COLOR, points)


def draw_debug_grid_overlay(
    surface: pygame.Surface,
    display_config: DisplayConfig,  # UI config
    rows: int,
    cols: int,
    cw: float,
    ch: float,
    ox: float,
    oy: float,
) -> None:
    """Draws debug information (coordinates) using pre-calculated render parameters."""
    font = display_config.DEBUG_FONT
    if not font:
        log.warning("Debug font not available for overlay.")
        return
    if cw <= 0 or ch <= 0:
        log.warning("Cannot draw debug overlay with zero cell dimensions.")
        return

    for r in range(rows):
        for c in range(cols):
            is_up = (r + c) % 2 != 0
            points = get_triangle_points(r, c, is_up, ox, oy, cw, ch)
            text = f"{r},{c}"
            text_surf = font.render(text, True, colors.DEBUG_TOGGLE_COLOR)
            center_x = sum(p[0] for p in points) / 3
            center_y = sum(p[1] for p in points) / 3
            text_rect = text_surf.get_rect(center=(center_x, center_y))
            surface.blit(text_surf, text_rect)


def draw_grid(
    surface: pygame.Surface,
    grid_data_np: dict[str, np.ndarray],
    env_config: EnvConfig,  # Core config
    display_config: DisplayConfig,  # UI config
    cw: float,
    ch: float,
    ox: float,
    oy: float,
    game_over: bool = False,
    debug_mode: bool = False,
) -> None:
    """Main function to draw the entire grid including background and state."""
    draw_grid_background(
        surface,
        env_config,
        display_config,
        cw,
        ch,
        ox,
        oy,
        game_over,
        debug_mode,
        grid_data_np["death"],
    )
    draw_grid_state(
        surface,
        grid_data_np["occupied"],
        grid_data_np["color_id"],
        grid_data_np["death"],
        env_config.ROWS,
        env_config.COLS,
        cw,
        ch,
        ox,
        oy,
    )
    # Overlay debug coordinates only if in debug mode
    # Note: draw_grid_background already handles drawing coords if debug_mode=True
    # This function might be redundant if the background function does it.
    # Keeping it separate allows potentially different debug info later.
    # if debug_mode:
    #     draw_debug_grid_overlay(
    #         surface, display_config, env_config.ROWS, env_config.COLS, cw, ch, ox, oy
    #     )


File: src/trianglengin/ui/visualization/drawing/shapes.py
# Guard UI imports
try:
    import pygame

    from ..core import colors  # Relative import
    from .utils import get_triangle_points  # Relative import
except ImportError as e:
    raise ImportError(
        "UI components require 'pygame'. Install with 'pip install trianglengin[ui]'."
    ) from e

# Use absolute imports for core components
from trianglengin.game_interface import Shape


def draw_shape(
    surface: pygame.Surface,
    shape: Shape,  # Core Shape
    topleft: tuple[int, int],
    cell_size: float,
    _is_selected: bool = False,  # Keep underscore if not used visually
    origin_offset: tuple[int, int] = (0, 0),
) -> None:
    """Draws a single shape onto a surface."""
    if not shape or not shape.triangles or cell_size <= 0:
        return

    shape_color = shape.color
    border_color = colors.GRAY  # Use a defined border color
    cw = cell_size
    ch = cell_size  # Assuming square aspect ratio for cells in preview

    for dr, dc, is_up in shape.triangles:
        # Adjust relative coords by origin offset (used for centering in previews)
        adj_r, adj_c = dr + origin_offset[0], dc + origin_offset[1]
        # Calculate top-left corner of the bounding box for this triangle
        tri_x = topleft[0] + adj_c * (cw * 0.75)
        tri_y = topleft[1] + adj_r * ch
        # Use helper to get points relative to (0,0) for local drawing
        # then translate them to the calculated tri_x, tri_y
        pts = [
            (px + tri_x, py + tri_y)
            for px, py in get_triangle_points(0, 0, is_up, 0, 0, cw, ch)
        ]
        pygame.draw.polygon(surface, shape_color, pts)
        pygame.draw.polygon(surface, border_color, pts, 1)  # Draw border


File: src/trianglengin/ui/visualization/drawing/previews.py
import logging

# Guard UI imports
try:
    import pygame

    # Import DisplayConfig from the correct UI location
    from trianglengin.ui.config import DisplayConfig

    from ..core import colors  # Relative import
    from .shapes import draw_shape  # Relative import
    from .utils import get_triangle_points  # Relative import
except ImportError as e:
    raise ImportError(
        "UI components require 'pygame'. Install with 'pip install trianglengin[ui]'."
    ) from e

# Use absolute imports for core components
from trianglengin.config import EnvConfig
from trianglengin.game_interface import Shape

logger = logging.getLogger(__name__)


def render_previews(
    surface: pygame.Surface,
    shapes: list[Shape | None],  # Core Shape
    area_topleft: tuple[int, int],
    _mode: str,
    env_config: EnvConfig,  # Core EnvConfig
    display_config: DisplayConfig,  # UI DisplayConfig
    selected_shape_idx: int = -1,
) -> dict[int, pygame.Rect]:
    """Renders shape previews in their area. Returns dict {index: screen_rect}."""
    surface.fill(colors.PREVIEW_BG_COLOR)
    preview_rects_screen: dict[int, pygame.Rect] = {}
    num_slots = env_config.NUM_SHAPE_SLOTS
    pad = display_config.PREVIEW_PADDING
    inner_pad = display_config.PREVIEW_INNER_PADDING
    border = display_config.PREVIEW_BORDER_WIDTH
    selected_border = display_config.PREVIEW_SELECTED_BORDER_WIDTH

    if num_slots <= 0:
        return {}

    total_pad_h = (num_slots + 1) * pad
    available_h = surface.get_height() - total_pad_h
    slot_h = available_h / num_slots if num_slots > 0 else 0
    slot_w = surface.get_width() - 2 * pad
    current_y = float(pad)

    for i in range(num_slots):
        slot_rect_local = pygame.Rect(pad, int(current_y), int(slot_w), int(slot_h))
        # Calculate absolute screen rect for collision detection later
        slot_rect_screen = slot_rect_local.move(area_topleft)
        preview_rects_screen[i] = slot_rect_screen

        shape: Shape | None = shapes[i] if i < len(shapes) else None
        is_selected = selected_shape_idx == i
        border_width = selected_border if is_selected else border
        border_color = (
            colors.PREVIEW_SELECTED_BORDER if is_selected else colors.PREVIEW_BORDER
        )
        # Draw border onto the local surface
        pygame.draw.rect(surface, border_color, slot_rect_local, border_width)

        if shape:
            # Calculate drawing area inside the border and padding
            draw_area_w = slot_w - 2 * (border_width + inner_pad)
            draw_area_h = slot_h - 2 * (border_width + inner_pad)
            if draw_area_w > 0 and draw_area_h > 0:
                min_r, min_c, max_r, max_c = shape.bbox()
                shape_rows = max_r - min_r + 1
                # Effective columns considering 0.75 width factor for triangles
                shape_cols_eff = (
                    (max_c - min_c + 1) * 0.75 + 0.25 if shape.triangles else 1
                )
                # Calculate scale to fit shape within draw area
                scale_w = (
                    draw_area_w / shape_cols_eff if shape_cols_eff > 0 else draw_area_w
                )
                scale_h = draw_area_h / shape_rows if shape_rows > 0 else draw_area_h
                cell_size = max(1.0, min(scale_w, scale_h))  # Use smallest scale

                # Calculate centered top-left position for drawing the shape
                shape_render_w = shape_cols_eff * cell_size
                shape_render_h = shape_rows * cell_size
                draw_topleft_x = (
                    slot_rect_local.left
                    + border_width
                    + inner_pad
                    + (draw_area_w - shape_render_w) / 2
                )
                draw_topleft_y = (
                    slot_rect_local.top
                    + border_width
                    + inner_pad
                    + (draw_area_h - shape_render_h) / 2
                )
                # Draw the shape onto the local surface
                draw_shape(
                    surface,
                    shape,
                    (int(draw_topleft_x), int(draw_topleft_y)),
                    cell_size,
                    _is_selected=is_selected,
                    origin_offset=(-min_r, -min_c),  # Adjust drawing origin
                )
        current_y += slot_h + pad
    return preview_rects_screen


def draw_placement_preview(
    surface: pygame.Surface,
    shape: Shape,  # Core Shape
    r: int,
    c: int,
    is_valid: bool,
    cw: float,
    ch: float,
    ox: float,
    oy: float,
) -> None:
    """Draws a semi-transparent shape snapped to the grid using pre-calculated parameters."""
    if not shape or not shape.triangles:
        return
    if cw <= 0 or ch <= 0:
        return

    alpha = 100
    base_color = (
        colors.PLACEMENT_VALID_COLOR if is_valid else colors.PLACEMENT_INVALID_COLOR
    )
    color: colors.ColorRGBA = (base_color[0], base_color[1], base_color[2], alpha)
    # Create a temporary surface for alpha blending
    temp_surface = pygame.Surface(surface.get_size(), pygame.SRCALPHA)
    temp_surface.fill((0, 0, 0, 0))  # Transparent background

    for dr, dc, is_up in shape.triangles:
        tri_r, tri_c = r + dr, c + dc
        # Use helper to get points relative to grid origin
        pts = get_triangle_points(tri_r, tri_c, is_up, ox, oy, cw, ch)
        pygame.draw.polygon(temp_surface, color, pts)

    # Blit the temporary surface onto the main surface
    surface.blit(temp_surface, (0, 0))


def draw_floating_preview(
    surface: pygame.Surface,
    shape: Shape,  # Core Shape
    screen_pos: tuple[int, int],
) -> None:
    """Draws a semi-transparent shape floating at the screen position."""
    if not shape or not shape.triangles:
        return

    cell_size = 20.0  # Fixed size for floating preview
    alpha = 100
    color: colors.ColorRGBA = (shape.color[0], shape.color[1], shape.color[2], alpha)
    # Create a temporary surface for alpha blending
    temp_surface = pygame.Surface(surface.get_size(), pygame.SRCALPHA)
    temp_surface.fill((0, 0, 0, 0))  # Transparent background

    # Center the shape around the screen_pos
    min_r, min_c, max_r, max_c = shape.bbox()
    center_r = (min_r + max_r) / 2.0
    center_c = (min_c + max_c) / 2.0

    for dr, dc, is_up in shape.triangles:
        # Calculate position relative to the center of the shape bbox
        pt_x = screen_pos[0] + (dc - center_c) * (cell_size * 0.75)
        pt_y = screen_pos[1] + (dr - center_r) * cell_size
        # Use helper to get points relative to (0,0) for local drawing
        rel_pts = get_triangle_points(0, 0, is_up, 0, 0, cell_size, cell_size)
        # Translate points to the calculated screen position
        pts = [(px + pt_x, py + pt_y) for px, py in rel_pts]
        pygame.draw.polygon(temp_surface, color, pts)

    # Blit the temporary surface onto the main surface
    surface.blit(temp_surface, (0, 0))


File: src/trianglengin/ui/visualization/drawing/__init__.py
"""Drawing functions for specific visual elements."""

# Guard UI imports
try:
    # Import the new utility function
    from .grid import (
        draw_debug_grid_overlay,
        draw_grid_background,
        draw_grid_state,
    )
    from .highlight import draw_debug_highlight
    from .hud import render_hud
    from .previews import (
        draw_floating_preview,
        draw_placement_preview,
        render_previews,
    )
    from .shapes import draw_shape
    from .utils import get_triangle_points

    __all__ = [
        "draw_grid_background",
        "draw_grid_state",
        "draw_debug_grid_overlay",
        "draw_shape",
        "render_previews",
        "draw_placement_preview",
        "draw_floating_preview",
        "render_hud",
        "draw_debug_highlight",
        "get_triangle_points",  # Export the helper
    ]

except ImportError as e:
    import warnings

    warnings.warn(
        f"Could not import UI drawing components ({e}). "
        "Ensure 'pygame' is installed (`pip install trianglengin[ui]`).",
        ImportWarning,
        stacklevel=2,
    )
    __all__ = []


File: src/trianglengin/ui/visualization/drawing/README.md

# UI Visualization Drawing Submodule (`trianglengin.ui.visualization.drawing`)

**Requires:** `pygame`

## Purpose and Architecture

This submodule contains specialized functions responsible for drawing specific visual elements of the game onto Pygame surfaces for the **interactive modes** within the `trianglengin.ui` package. These functions are typically called by the core renderer (`Visualizer`) in [`trianglengin.ui.visualization.core`](../core/README.md).

-   **[`grid.py`](grid.py):** Functions for drawing the grid background (`draw_grid_background`), the individual triangles within it colored based on occupancy/emptiness (`draw_grid_state`), and optional debug overlays (`draw_debug_grid_overlay`).
-   **[`shapes.py`](shapes.py):** Contains `draw_shape`, a function to render a given `Shape` object at a specific location on a surface (used primarily for previews).
-   **[`previews.py`](previews.py):** Handles rendering related to shape previews:
    -   `render_previews`: Draws the dedicated preview area, including borders and the shapes within their slots, handling selection highlights.
    -   `draw_placement_preview`: Draws a semi-transparent version of a shape snapped to the grid, indicating a potential placement location (used in play mode hover).
    -   `draw_floating_preview`: Draws a semi-transparent shape directly under the mouse cursor when hovering over the grid but not snapped (used in play mode hover).
-   **[`hud.py`](hud.py):** `render_hud` draws Heads-Up Display elements like help text onto the main screen surface (simplified for interactive modes).
-   **[`highlight.py`](highlight.py):** `draw_debug_highlight` draws a distinct border around a specific triangle, used for visual feedback in debug mode.
-   **[`utils.py`](utils.py):** Helper functions, like `get_triangle_points`, used by other drawing functions.

## Exposed Interfaces

-   **Grid Drawing:**
    -   `draw_grid_background(...)`
    -   `draw_grid_state(...)`
    -   `draw_debug_grid_overlay(...)`
-   **Shape Drawing:**
    -   `draw_shape(...)`
-   **Preview Drawing:**
    -   `render_previews(...) -> Dict[int, pygame.Rect]`
    -   `draw_placement_preview(...)`
    -   `draw_floating_preview(...)`
-   **HUD Drawing:**
    -   `render_hud(...)`
-   **Highlight Drawing:**
    -   `draw_debug_highlight(...)`
-   **Utilities:**
    -   `get_triangle_points(...) -> list[tuple[float, float]]`

## Dependencies

-   **`trianglengin` (core):** `EnvConfig`, `GameState`, `Shape`.
-   **`trianglengin.ui.config`**: `DisplayConfig`.
-   **`trianglengin.ui.visualization.core`**: `colors`, `coord_mapper`.
-   **`pygame`**: The core library used for all drawing operations.
-   **Standard Libraries:** `typing`, `logging`, `math`.

---

**Note:** Please keep this README updated when adding new drawing functions, modifying existing ones, or changing their dependencies.

File: src/trianglengin/ui/visualization/drawing/utils.py
"""Utility functions for the drawing module."""


def get_triangle_points(
    r: int, c: int, is_up: bool, ox: float, oy: float, cw: float, ch: float
) -> list[tuple[float, float]]:
    """
    Calculates vertex points for drawing a triangle, relative to origin (ox, oy).
    """
    # Top-left corner of the bounding rectangle for the cell (r, c)
    # Note the horizontal offset depends only on column (c * 0.75 * cw)
    # Note the vertical offset depends only on row (r * ch)
    x = ox + c * (cw * 0.75)
    y = oy + r * ch

    if is_up:
        # Points for an upward-pointing triangle (base at bottom)
        # Vertices: Bottom-left, Bottom-right, Top-middle
        return [(x, y + ch), (x + cw, y + ch), (x + cw / 2, y)]
    else:
        # Points for a downward-pointing triangle (base at top)
        # Vertices: Top-left, Top-right, Bottom-middle
        return [(x, y), (x + cw, y), (x + cw / 2, y + ch)]


File: src/trianglengin/ui/visualization/drawing/hud.py
from typing import Any

# Guard UI imports
try:
    import pygame

    from ..core import colors  # Relative import
except ImportError as e:
    raise ImportError(
        "UI components require 'pygame'. Install with 'pip install trianglengin[ui]'."
    ) from e


def render_hud(
    surface: pygame.Surface,
    mode: str,
    fonts: dict[str, pygame.font.Font | None],
    _display_stats: dict[str, Any] | None = None,  # Prefix with underscore
) -> None:
    """
    Renders HUD elements for interactive modes (play/debug).
    Displays only help text relevant to the mode.
    Ignores _display_stats.
    """
    screen_w, screen_h = surface.get_size()
    help_font = fonts.get("help")

    if not help_font:
        return

    bottom_y = screen_h - 10  # Position from bottom

    # --- Render Help Text Only ---
    help_text = "[ESC] Quit"
    if mode == "play":
        help_text += " | [Click] Select/Place Shape"
    elif mode == "debug":
        help_text += " | [Click] Toggle Cell"

    help_surf = help_font.render(help_text, True, colors.LIGHT_GRAY)
    # Position help text at the bottom right
    help_rect = help_surf.get_rect(bottomright=(screen_w - 15, bottom_y))
    surface.blit(help_surf, help_rect)


File: src/trianglengin/ui/visualization/drawing/highlight.py
# Guard UI imports
try:
    import pygame

    from ..core import colors  # Relative import
    from .utils import get_triangle_points  # Relative import
except ImportError as e:
    raise ImportError(
        "UI components require 'pygame'. Install with 'pip install trianglengin[ui]'."
    ) from e


def draw_debug_highlight(
    surface: pygame.Surface,
    r: int,
    c: int,
    cw: float,
    ch: float,
    ox: float,
    oy: float,
) -> None:
    """Highlights a specific triangle border for debugging using pre-calculated parameters."""
    if surface.get_width() <= 0 or surface.get_height() <= 0:
        return
    if cw <= 0 or ch <= 0:
        return

    is_up = (r + c) % 2 != 0
    # Use helper
    pts = get_triangle_points(r, c, is_up, ox, oy, cw, ch)
    pygame.draw.polygon(surface, colors.DEBUG_TOGGLE_COLOR, pts, 3)  # Draw border


File: src/trianglengin/ui/visualization/core/layout.py
"""
Functions to calculate the layout of UI elements based on screen size and config.
"""

import logging

import pygame  # Required dependency

# Use absolute imports
from trianglengin.ui.config import DisplayConfig

logger = logging.getLogger(__name__)


def calculate_interactive_layout(
    screen_width: int, screen_height: int, config: DisplayConfig
) -> dict[str, pygame.Rect]:
    """
    Calculates layout rectangles for interactive modes (play/debug).

    Args:
        screen_width: Current width of the screen/window.
        screen_height: Current height of the screen/window.
        config: The DisplayConfig object.

    Returns:
        A dictionary mapping area names ('grid', 'preview') to pygame.Rect objects.
    """
    pad = config.PADDING
    hud_h = config.HUD_HEIGHT
    preview_w = config.PREVIEW_AREA_WIDTH

    # Available height after accounting for top/bottom padding and HUD
    available_h = screen_height - 2 * pad - hud_h
    # Available width after accounting for left/right padding and preview area
    available_w = screen_width - 3 * pad - preview_w

    if available_w <= 0 or available_h <= 0:
        logger.warning(
            f"Screen size ({screen_width}x{screen_height}) too small for layout."
        )
        # Return minimal valid rects to avoid errors downstream
        return {
            "grid": pygame.Rect(pad, pad, 1, 1),
            "preview": pygame.Rect(screen_width - pad - preview_w, pad, 1, 1),
        }

    # Grid area takes up the main left space
    grid_rect = pygame.Rect(pad, pad, available_w, available_h)

    # Preview area is on the right
    preview_rect = pygame.Rect(grid_rect.right + pad, pad, preview_w, available_h)

    # HUD area (optional, could be drawn directly without a rect)
    # hud_rect = pygame.Rect(pad, grid_rect.bottom + pad, screen_width - 2 * pad, hud_h)

    return {"grid": grid_rect, "preview": preview_rect}


def calculate_training_layout(
    screen_width: int, screen_height: int, config: DisplayConfig
) -> dict[str, pygame.Rect]:
    """
    Calculates layout rectangles for training/headless visualization (if needed).
    Currently simple, just uses the whole screen for the grid.

    Args:
        screen_width: Current width of the screen/window.
        screen_height: Current height of the screen/window.
        config: The DisplayConfig object.

    Returns:
        A dictionary mapping area names ('grid') to pygame.Rect objects.
    """
    pad = config.PADDING
    grid_rect = pygame.Rect(pad, pad, screen_width - 2 * pad, screen_height - 2 * pad)
    return {"grid": grid_rect}


File: src/trianglengin/ui/visualization/core/__init__.py
"""Core visualization components: renderers, layout, fonts, colors, coordinate mapping."""

# Direct imports - if pygame is missing, these will fail, which is intended behavior
# for the optional UI package.
from . import colors, coord_mapper, fonts, layout  # Import modules needed by others

# Visualizer is NOT exported from here to avoid circular imports.
# Import it directly: from trianglengin.ui.visualization.core.visualizer import Visualizer

__all__ = [
    # "Visualizer", # REMOVED
    "layout",
    "fonts",
    "colors",
    "coord_mapper",
]


File: src/trianglengin/ui/visualization/core/README.md


# UI Visualization Core Submodule (`trianglengin.ui.visualization.core`)

**Requires:** `pygame`

## Purpose and Architecture

This submodule contains the central classes and foundational elements for the **interactive** visualization system within the `trianglengin.ui` package. It orchestrates rendering for play/debug modes, manages layout and coordinate systems, and defines core visual properties like colors and fonts.

-   **Render Orchestration:**
    -   [`Visualizer`](visualizer.py): The main class for rendering in **interactive modes** ("play", "debug"). It maintains the Pygame screen, calculates layout using `layout.py`, manages cached preview area rectangles, and calls appropriate drawing functions from [`trianglengin.ui.visualization.drawing`](../drawing/README.md). **It receives interaction state (hover position, selected index) via its `render` method to display visual feedback.**
-   **Layout Management:**
    -   [`layout.py`](layout.py): Contains functions (`calculate_interactive_layout`, `calculate_training_layout`) to determine the size and position of the main UI areas based on the screen dimensions, mode, and `DisplayConfig`.
-   **Coordinate System:**
    -   [`coord_mapper.py`](coord_mapper.py): Provides essential mapping functions:
        -   `_calculate_render_params`: Internal helper to get scaling and offset for grid rendering.
        -   `get_grid_coords_from_screen`: Converts mouse/screen coordinates into logical grid (row, column) coordinates.
        -   `get_preview_index_from_screen`: Converts mouse/screen coordinates into the index of the shape preview slot being pointed at.
-   **Visual Properties:**
    -   [`colors.py`](colors.py): Defines a centralized palette of named color constants (RGB tuples).
    -   [`fonts.py`](fonts.py): Contains the `load_fonts` function to load and manage Pygame font objects.

## Exposed Interfaces

-   **Classes:**
    -   `Visualizer` (Import directly from `visualizer.py`, not exported here)
-   **Functions:**
    -   `calculate_interactive_layout(...) -> Dict[str, pygame.Rect]`
    -   `calculate_training_layout(...) -> Dict[str, pygame.Rect]` (Kept for potential future use)
    -   `load_fonts() -> Dict[str, Optional[pygame.font.Font]]`
    -   `get_grid_coords_from_screen(...) -> Optional[Tuple[int, int]]`
    -   `get_preview_index_from_screen(...) -> Optional[int]`
-   **Modules:**
    -   `colors`: Provides color constants (e.g., `colors.RED`).
    -   `layout`: Provides layout calculation functions.
    -   `coord_mapper`: Provides coordinate mapping functions.
    -   `fonts`: Provides font loading functions.

## Dependencies

-   **`trianglengin` (core):** `GameState`, `EnvConfig`, `Shape`.
-   **`trianglengin.ui.config`**: `DisplayConfig`.
-   **`trianglengin.utils`**: `geometry`.
-   **`trianglengin.ui.visualization.drawing`**: Drawing functions are called by `Visualizer`.
-   **`pygame`**: Used for surfaces, rectangles, fonts, display management.
-   **Standard Libraries:** `typing`, `logging`, `math`.

---

**Note:** Please keep this README updated when changing the core rendering logic, layout calculations, coordinate mapping, or the interfaces of the renderers.


File: src/trianglengin/ui/visualization/core/coord_mapper.py
# Guard UI imports
try:
    import pygame
except ImportError as e:
    raise ImportError(
        "UI components require 'pygame'. Install with 'pip install trianglengin[ui]'."
    ) from e

# Use absolute imports for core components
from trianglengin.config import EnvConfig
from trianglengin.utils import geometry

# Correct the import path for the drawing utility (relative within UI)
from ..drawing.utils import get_triangle_points


def _calculate_render_params(
    width: int, height: int, config: EnvConfig
) -> tuple[float, float, float, float]:
    """Calculates scale (cw, ch) and offset (ox, oy) for rendering the grid."""
    rows, cols = config.ROWS, config.COLS
    cols_eff = cols * 0.75 + 0.25 if cols > 0 else 1
    scale_w = width / cols_eff if cols_eff > 0 else 1
    scale_h = height / rows if rows > 0 else 1
    scale = max(1.0, min(scale_w, scale_h))
    cell_size = scale
    grid_w_px = cols_eff * cell_size
    grid_h_px = rows * cell_size
    offset_x = (width - grid_w_px) / 2
    offset_y = (height - grid_h_px) / 2
    return cell_size, cell_size, offset_x, offset_y


def get_grid_coords_from_screen(
    screen_pos: tuple[int, int], grid_area_rect: pygame.Rect, config: EnvConfig
) -> tuple[int, int] | None:
    """Maps screen coordinates (relative to screen) to grid row/column."""
    if not grid_area_rect or not grid_area_rect.collidepoint(screen_pos):
        return None

    local_x = screen_pos[0] - grid_area_rect.left
    local_y = screen_pos[1] - grid_area_rect.top
    cw, ch, ox, oy = _calculate_render_params(
        grid_area_rect.width, grid_area_rect.height, config
    )
    if cw <= 0 or ch <= 0:
        return None

    # Estimate row/col based on overall position
    row = int((local_y - oy) / ch) if ch > 0 else -1
    # Approximate column based on horizontal position, accounting for 0.75 width factor
    approx_col_center_index = (local_x - ox - cw / 4) / (cw * 0.75) if cw > 0 else -1
    col = int(round(approx_col_center_index))

    # Check the estimated cell and its immediate neighbors using point-in-polygon
    # This is more accurate near triangle boundaries
    for r_check in [row, row - 1, row + 1]:
        if not (0 <= r_check < config.ROWS):
            continue
        # Check a slightly wider range of columns due to triangular nature
        for c_check in [col - 1, col, col + 1, col + 2]:
            if not (0 <= c_check < config.COLS):
                continue
            is_up = (r_check + c_check) % 2 != 0
            pts = get_triangle_points(r_check, c_check, is_up, ox, oy, cw, ch)
            # Use the geometry utility function
            if geometry.is_point_in_polygon((local_x, local_y), pts):
                return r_check, c_check

    # Fallback if point-in-polygon check fails (should be rare)
    if 0 <= row < config.ROWS and 0 <= col < config.COLS:
        return row, col
    return None


def get_preview_index_from_screen(
    screen_pos: tuple[int, int], preview_rects: dict[int, pygame.Rect]
) -> int | None:
    """Maps screen coordinates to a shape preview index."""
    if not preview_rects:
        return None
    for idx, rect in preview_rects.items():
        if rect and rect.collidepoint(screen_pos):
            return idx
    return None


File: src/trianglengin/ui/visualization/core/fonts.py
import logging

# Guard UI imports
try:
    import pygame

    pygame.font.init()  # Initialize font module here
except ImportError as e:
    raise ImportError(
        "UI components require 'pygame'. Install with 'pip install trianglengin[ui]'."
    ) from e

logger = logging.getLogger(__name__)

DEFAULT_FONT_NAME = None
FALLBACK_FONT_NAME = "arial,freesans"


def load_single_font(name: str | None, size: int) -> pygame.font.Font | None:
    """Loads a single font, handling potential errors."""
    try:
        font = pygame.font.SysFont(name, size)
        return font
    except Exception as e:
        logger.error(f"Error loading font '{name}' size {size}: {e}")
        if name != FALLBACK_FONT_NAME:
            logger.warning(f"Attempting fallback font: {FALLBACK_FONT_NAME}")
            try:
                font = pygame.font.SysFont(FALLBACK_FONT_NAME, size)
                logger.info(f"Loaded fallback font: {FALLBACK_FONT_NAME} size {size}")
                return font
            except Exception as e_fallback:
                logger.error(f"Fallback font failed: {e_fallback}")
                return None
        return None


def load_fonts(
    font_sizes: dict[str, int] | None = None,
) -> dict[str, pygame.font.Font | None]:
    """Loads standard game fonts."""
    if font_sizes is None:
        font_sizes = {
            "ui": 24,
            "score": 30,
            "help": 18,
            "title": 48,
            # Add debug font size if needed, though DisplayConfig handles the object
            "debug": 12,
        }

    fonts: dict[str, pygame.font.Font | None] = {}
    required_fonts = ["score", "help"]

    logger.info("Loading fonts...")
    for name, size in font_sizes.items():
        fonts[name] = load_single_font(DEFAULT_FONT_NAME, size)

    for name in required_fonts:
        if fonts.get(name) is None:
            logger.critical(
                f"Essential font '{name}' failed to load. Text rendering will be affected."
            )

    return fonts


File: src/trianglengin/ui/visualization/core/visualizer.py
import logging

import numpy as np
import pygame  # Now a required dependency

# Use absolute imports for core components
from trianglengin.config import EnvConfig
from trianglengin.game_interface import GameState, Shape

# Use absolute imports within UI package where needed
from trianglengin.ui.config import DisplayConfig

# Import specific modules directly from the core package
from trianglengin.ui.visualization.core import colors, coord_mapper
from trianglengin.ui.visualization.core import (
    layout as layout_module,
)  # Import layout directly

# Import drawing functions using absolute paths
from trianglengin.ui.visualization.drawing import grid as grid_drawing
from trianglengin.ui.visualization.drawing import highlight as highlight_drawing
from trianglengin.ui.visualization.drawing import hud as hud_drawing
from trianglengin.ui.visualization.drawing import previews as preview_drawing
from trianglengin.ui.visualization.drawing.previews import (
    draw_floating_preview,
    draw_placement_preview,
)

logger = logging.getLogger(__name__)


class Visualizer:
    """
    Orchestrates rendering of a single game state for interactive modes.
    Uses the GameState wrapper to access C++ state.
    Receives interaction state (hover, selection) via render parameters.
    """

    def __init__(
        self,
        screen: pygame.Surface,
        display_config: DisplayConfig,  # From UI config
        env_config: EnvConfig,  # From core config
        fonts: dict[str, pygame.font.Font | None],
    ) -> None:
        self.screen = screen
        self.display_config = display_config
        self.env_config = env_config
        self.fonts = fonts
        self.layout_rects: dict[str, pygame.Rect] | None = None
        self.preview_rects: dict[int, pygame.Rect] = {}
        self._layout_calculated_for_size: tuple[int, int] = (0, 0)
        self.ensure_layout()

    def ensure_layout(self) -> dict[str, pygame.Rect]:
        """Returns cached layout or calculates it if needed."""
        current_w, current_h = self.screen.get_size()
        current_size = (current_w, current_h)

        if (
            self.layout_rects is None
            or self._layout_calculated_for_size != current_size
        ):
            # Call the function via the imported module
            self.layout_rects = layout_module.calculate_interactive_layout(
                current_w,
                current_h,
                self.display_config,
            )
            self._layout_calculated_for_size = current_size
            logger.info(
                f"Recalculated interactive layout for size {current_size}: {self.layout_rects}"
            )
            self.preview_rects = {}  # Clear preview rect cache on layout change

        return self.layout_rects if self.layout_rects is not None else {}

    def render(
        self,
        game_state: GameState,  # Core GameState
        mode: str,
        selected_shape_idx: int = -1,
        hover_shape: Shape | None = None,  # Core Shape
        hover_grid_coord: tuple[int, int] | None = None,
        hover_is_valid: bool = False,
        hover_screen_pos: tuple[int, int] | None = None,
        debug_highlight_coord: tuple[int, int] | None = None,
    ) -> None:
        """Renders the entire game visualization for interactive modes."""
        self.screen.fill(colors.GRID_BG_DEFAULT)
        layout_rects = self.ensure_layout()
        grid_rect = layout_rects.get("grid")
        preview_rect = layout_rects.get("preview")

        grid_data_np = game_state.get_grid_data_np()

        if grid_rect and grid_rect.width > 0 and grid_rect.height > 0:
            try:
                grid_surf = self.screen.subsurface(grid_rect)
                cw, ch, ox, oy = coord_mapper._calculate_render_params(
                    grid_rect.width, grid_rect.height, self.env_config
                )
                self._render_grid_area(
                    grid_surf,
                    game_state,
                    grid_data_np,
                    mode,
                    grid_rect,
                    hover_shape,
                    hover_grid_coord,
                    hover_is_valid,
                    hover_screen_pos,
                    debug_highlight_coord,
                    cw,
                    ch,
                    ox,
                    oy,
                )
            except ValueError as e:
                logger.error(f"Error creating grid subsurface ({grid_rect}): {e}")
                pygame.draw.rect(self.screen, colors.RED, grid_rect, 1)

        if preview_rect and preview_rect.width > 0 and preview_rect.height > 0:
            try:
                preview_surf = self.screen.subsurface(preview_rect)
                self._render_preview_area(
                    preview_surf, game_state, mode, preview_rect, selected_shape_idx
                )
            except ValueError as e:
                logger.error(f"Error creating preview subsurface ({preview_rect}): {e}")
                pygame.draw.rect(self.screen, colors.RED, preview_rect, 1)

        hud_drawing.render_hud(
            surface=self.screen,
            mode=mode,
            fonts=self.fonts,
        )

    def _render_grid_area(
        self,
        grid_surf: pygame.Surface,
        game_state: GameState,
        grid_data_np: dict[str, np.ndarray],
        mode: str,
        grid_rect: pygame.Rect,
        hover_shape: Shape | None,
        hover_grid_coord: tuple[int, int] | None,
        hover_is_valid: bool,
        hover_screen_pos: tuple[int, int] | None,
        debug_highlight_coord: tuple[int, int] | None,
        cw: float,
        ch: float,
        ox: float,
        oy: float,
    ) -> None:
        """Renders the main game grid and overlays onto the provided grid_surf."""
        grid_drawing.draw_grid_background(
            grid_surf,
            self.env_config,
            self.display_config,
            cw,
            ch,
            ox,
            oy,
            game_state.is_over(),
            mode == "debug",
            death_mask_np=grid_data_np["death"],
        )

        grid_drawing.draw_grid_state(
            grid_surf,
            occupied_np=grid_data_np["occupied"],
            color_id_np=grid_data_np["color_id"],
            death_np=grid_data_np["death"],
            rows=self.env_config.ROWS,
            cols=self.env_config.COLS,
            cw=cw,
            ch=ch,
            ox=ox,
            oy=oy,
        )

        if mode == "play" and hover_shape:
            if hover_grid_coord:
                draw_placement_preview(
                    grid_surf,
                    hover_shape,
                    hover_grid_coord[0],
                    hover_grid_coord[1],
                    is_valid=hover_is_valid,
                    cw=cw,
                    ch=ch,
                    ox=ox,
                    oy=oy,
                )
            elif hover_screen_pos:
                local_hover_pos = (
                    hover_screen_pos[0] - grid_rect.left,
                    hover_screen_pos[1] - grid_rect.top,
                )
                if grid_surf.get_rect().collidepoint(local_hover_pos):
                    draw_floating_preview(
                        grid_surf,
                        hover_shape,
                        local_hover_pos,
                    )

        if mode == "debug" and debug_highlight_coord:
            r, c = debug_highlight_coord
            highlight_drawing.draw_debug_highlight(
                grid_surf,
                r,
                c,
                cw=cw,
                ch=ch,
                ox=ox,
                oy=oy,
            )

        score_font = self.fonts.get("score")
        if score_font:
            score_text = f"Score: {game_state.game_score():.0f}"
            score_surf = score_font.render(score_text, True, colors.YELLOW)
            score_rect = score_surf.get_rect(topleft=(5, 5))
            grid_surf.blit(score_surf, score_rect)

    def _render_preview_area(
        self,
        preview_surf: pygame.Surface,
        game_state: GameState,
        mode: str,
        preview_rect: pygame.Rect,
        selected_shape_idx: int,
    ) -> None:
        """Renders the shape preview slots onto preview_surf and caches rects."""
        current_shapes = game_state.get_shapes()
        current_preview_rects = preview_drawing.render_previews(
            preview_surf,
            current_shapes,
            preview_rect.topleft,
            mode,
            self.env_config,
            self.display_config,
            selected_shape_idx=selected_shape_idx,
        )
        # Cache the absolute screen coordinates of the preview slots
        if not self.preview_rects or self.preview_rects != current_preview_rects:
            self.preview_rects = current_preview_rects


File: src/trianglengin/ui/visualization/core/colors.py
"""
Defines color constants and mappings used throughout the application,
especially for visualization.
"""

# Define the Color type alias (RGB)
Color = tuple[int, int, int]
# Define RGBA type alias for clarity where alpha is used
ColorRGBA = tuple[int, int, int, int]

# --- Standard Colors ---
WHITE: Color = (255, 255, 255)
BLACK: Color = (0, 0, 0)
GRAY: Color = (128, 128, 128)
LIGHT_GRAY: Color = (200, 200, 200)
DARK_GRAY: Color = (50, 50, 50)
RED: Color = (255, 0, 0)
GREEN: Color = (0, 255, 0)
BLUE: Color = (0, 0, 255)
YELLOW: Color = (255, 255, 0)
CYAN: Color = (0, 255, 255)
MAGENTA: Color = (255, 0, 255)
ORANGE: Color = (255, 165, 0)
PURPLE: Color = (128, 0, 128)
TEAL: Color = (0, 128, 128)
OLIVE: Color = (128, 128, 0)

# --- Game Specific Colors ---
# Colors used for the placeable shapes
# These should align with the colors used/generated by the C++ core if specified there,
# or be used to interpret the color_id returned by the C++ core.
SHAPE_COLORS: tuple[Color, ...] = (
    (220, 40, 40),  # 0: Red
    (60, 60, 220),  # 1: Blue
    (40, 200, 40),  # 2: Green
    (230, 230, 40),  # 3: Yellow
    (240, 150, 20),  # 4: Orange
    (140, 40, 140),  # 5: Purple
    (40, 200, 200),  # 6: Cyan
    (200, 100, 180),  # 7: Pink
    (100, 180, 200),  # 8: Light Blue
)

# Mapping from Color ID (returned by C++) to RGB tuple for visualization.
ID_TO_COLOR_MAP: dict[int, Color] = dict(enumerate(SHAPE_COLORS))

# Special Color IDs (ensure these match C++ constants)
NO_COLOR_ID: int = -1
DEBUG_COLOR_ID: int = -2

# Grid background colors
GRID_BG_LIGHT: Color = (40, 40, 40)
GRID_BG_DARK: Color = (30, 30, 30)
GRID_LINE_COLOR: Color = (80, 80, 80)
DEATH_ZONE_COLOR: Color = (60, 0, 0)
TRIANGLE_EMPTY_COLOR: Color = GRAY
GRID_BG_DEFAULT: Color = DARK_GRAY
GRID_BG_GAME_OVER: Color = (70, 30, 30)

# UI Colors
HUD_BG_COLOR: Color = (20, 20, 20)
HUD_TEXT_COLOR: Color = WHITE
PREVIEW_BG_COLOR: Color = (25, 25, 25)
PREVIEW_BORDER: Color = GRAY
PREVIEW_SELECTED_BORDER: Color = WHITE

# Highlight Colors
HIGHLIGHT_VALID_COLOR: Color = GREEN
HIGHLIGHT_INVALID_COLOR: Color = RED
PLACEMENT_VALID_COLOR: Color = GREEN
PLACEMENT_INVALID_COLOR: Color = RED

# Debug Colors
DEBUG_TOGGLE_COLOR: Color = MAGENTA

__all__ = [
    "Color",
    "ColorRGBA",
    "WHITE",
    "BLACK",
    "GRAY",
    "LIGHT_GRAY",
    "DARK_GRAY",
    "RED",
    "GREEN",
    "BLUE",
    "YELLOW",
    "CYAN",
    "MAGENTA",
    "ORANGE",
    "PURPLE",
    "TEAL",
    "OLIVE",
    "SHAPE_COLORS",  # Keep if needed elsewhere, but ID_TO_COLOR_MAP is primary
    "ID_TO_COLOR_MAP",
    "NO_COLOR_ID",
    "DEBUG_COLOR_ID",
    "GRID_BG_LIGHT",
    "GRID_BG_DARK",
    "GRID_LINE_COLOR",
    "DEATH_ZONE_COLOR",
    "TRIANGLE_EMPTY_COLOR",
    "GRID_BG_DEFAULT",
    "GRID_BG_GAME_OVER",
    "HUD_BG_COLOR",
    "HUD_TEXT_COLOR",
    "PREVIEW_BG_COLOR",
    "PREVIEW_BORDER",
    "PREVIEW_SELECTED_BORDER",
    "HIGHLIGHT_VALID_COLOR",
    "HIGHLIGHT_INVALID_COLOR",
    "PLACEMENT_VALID_COLOR",
    "PLACEMENT_INVALID_COLOR",
    "DEBUG_TOGGLE_COLOR",
]


File: src/trianglengin/ui/interaction/event_processor.py
import logging
from collections.abc import Generator
from typing import TYPE_CHECKING, Any

# Guard UI imports
try:
    import pygame
except ImportError as e:
    raise ImportError(
        "UI components require 'pygame'. Install with 'pip install trianglengin[ui]'."
    ) from e

if TYPE_CHECKING:
    # Use internal import relative to UI package
    from ..visualization.core.visualizer import Visualizer

logger = logging.getLogger(__name__)


def process_pygame_events(
    visualizer: "Visualizer",
) -> Generator[pygame.event.Event, Any, bool]:
    """
    Processes basic Pygame events like QUIT, ESCAPE, VIDEORESIZE.
    Yields other events for mode-specific handlers.
    Returns False via StopIteration value if the application should quit, True otherwise.
    """
    should_quit = False
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            logger.info("Received QUIT event.")
            should_quit = True
            break
        if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
            logger.info("Received ESCAPE key press.")
            should_quit = True
            break
        if event.type == pygame.VIDEORESIZE:
            try:
                w, h = max(320, event.w), max(240, event.h)
                visualizer.screen = pygame.display.set_mode((w, h), pygame.RESIZABLE)
                visualizer.layout_rects = None
                logger.info(f"Window resized to {w}x{h}")
            except pygame.error as e:
                logger.error(f"Error resizing window: {e}")
            yield event
        else:
            yield event
    return not should_quit


File: src/trianglengin/ui/interaction/__init__.py
# src/trianglengin/ui/interaction/__init__.py
"""
Interaction handling module for interactive modes (play/debug).
"""

# Direct imports - if pygame is missing, these will fail.
from .debug_mode_handler import handle_debug_click, update_debug_hover
from .event_processor import process_pygame_events
from .input_handler import InputHandler
from .play_mode_handler import handle_play_click, update_play_hover

__all__ = [
    "InputHandler",
    "process_pygame_events",
    "handle_play_click",
    "update_play_hover",
    "handle_debug_click",
    "update_debug_hover",
]


File: src/trianglengin/ui/interaction/README.md

# UI Interaction Module (`trianglengin.ui.interaction`)

**Requires:** `pygame`

## Purpose

This submodule handles user input (keyboard and mouse) for the interactive modes ("play", "debug") provided by the `trianglengin.ui` package. It bridges the gap between raw Pygame events and actions within the game simulation (`GameState` from the core engine).

-   **Event Processing:** [`event_processor.py`](event_processor.py) handles common Pygame events like quitting (QUIT, ESC) and window resizing. It acts as a generator, yielding other events for mode-specific processing.
-   **Input Handler:** The [`InputHandler`](input_handler.py) class is the main entry point for this submodule.
    -   It receives Pygame events (via the `event_processor`).
    -   It **manages interaction-specific state** internally (e.g., `selected_shape_idx`, `hover_grid_coord`, `debug_highlight_coord`).
    -   It determines the current interaction mode ("play" or "debug") and delegates event handling and hover updates to specific handler functions ([`play_mode_handler.py`](play_mode_handler.py), [`debug_mode_handler.py`](debug_mode_handler.py)).
    -   It provides the necessary interaction state to the `trianglengin.ui.visualization.Visualizer` for rendering feedback (hover previews, selection highlights).
-   **Mode-Specific Handlers:** `play_mode_handler.py` and `debug_mode_handler.py` contain the logic specific to each mode, operating on the `InputHandler`'s state and the core `GameState`.
    -   `play`: Handles selecting shapes, checking placement validity, and triggering `GameState.step` on valid clicks. Updates hover state in the `InputHandler`.
    -   `debug`: Handles toggling the state of individual triangles directly using `GameState.debug_toggle_cell`. Updates hover state in the `InputHandler`.
-   **Decoupling:** It separates input handling logic from the core game simulation (`trianglengin`) and rendering (`trianglengin.ui.visualization`), although it needs references to both to function within the UI application.

## Exposed Interfaces

-   **Classes:**
    -   `InputHandler`:
        -   `__init__(game_state: GameState, visualizer: Visualizer, mode: str, env_config: EnvConfig)`
        -   `handle_input() -> bool`: Processes events for one frame, returns `False` if quitting.
        -   `get_render_interaction_state() -> dict`: Returns interaction state needed by `Visualizer.render`.
-   **Functions:**
    -   `process_pygame_events(visualizer: Visualizer) -> Generator[pygame.event.Event, Any, bool]`: Processes common events, yields others.
    -   `handle_play_click(event: pygame.event.Event, handler: InputHandler)`: Handles clicks in play mode.
    -   `update_play_hover(handler: InputHandler)`: Updates hover state in play mode.
    -   `handle_debug_click(event: pygame.event.Event, handler: InputHandler)`: Handles clicks in debug mode.
    -   `update_debug_hover(handler: InputHandler)`: Updates hover state in debug mode.

## Dependencies

-   **`trianglengin` (core):** `GameState`, `EnvConfig`, `Shape`.
-   **`trianglengin.ui.visualization`**: `Visualizer`, `coord_mapper`.
-   **`pygame`**: Relies heavily on Pygame for event handling (`pygame.event`, `pygame.mouse`) and constants (`MOUSEBUTTONDOWN`, `KEYDOWN`, etc.).
-   **Standard Libraries:** `typing`, `logging`.

---

**Note:** Please keep this README updated when adding new interaction modes, changing input handling logic, or modifying the interfaces between interaction, environment, and visualization.


File: src/trianglengin/ui/interaction/input_handler.py
import logging

# Use absolute imports for core components
from trianglengin.config import EnvConfig
from trianglengin.game_interface import GameState, Shape

# Guard UI imports
try:
    import pygame

    from ..visualization import Visualizer  # Relative import within UI package
    from . import debug_mode_handler, event_processor, play_mode_handler  # Relative
except ImportError as e:
    raise ImportError(
        "UI components require 'pygame'. Install with 'pip install trianglengin[ui]'."
    ) from e


logger = logging.getLogger(__name__)


class InputHandler:
    """
    Handles user input, manages interaction state (selection, hover),
    and delegates actions to mode-specific handlers. Uses the GameState wrapper.
    """

    def __init__(
        self,
        game_state: GameState,  # Uses the core GameState wrapper
        visualizer: Visualizer,  # Uses the UI Visualizer
        mode: str,
        env_config: EnvConfig,  # Uses the core EnvConfig
    ):
        self.game_state = game_state
        self.visualizer = visualizer
        self.mode = mode
        self.env_config = env_config

        # Interaction state managed here
        self.selected_shape_idx: int = -1
        self.hover_grid_coord: tuple[int, int] | None = None
        self.hover_is_valid: bool = False
        self.hover_shape: Shape | None = None  # Uses the core Shape struct
        self.debug_highlight_coord: tuple[int, int] | None = None
        self.mouse_pos: tuple[int, int] = (0, 0)

    def handle_input(self) -> bool:
        """Processes Pygame events and updates state based on mode. Returns False to quit."""
        self.mouse_pos = pygame.mouse.get_pos()

        # Reset hover/highlight state each frame before processing events/updates
        self.hover_grid_coord = None
        self.hover_is_valid = False
        self.hover_shape = None
        self.debug_highlight_coord = None

        running = True
        event_generator = event_processor.process_pygame_events(self.visualizer)
        try:
            while True:
                event = next(event_generator)
                # Pass self to handlers so they can modify interaction state
                if self.mode == "play":
                    play_mode_handler.handle_play_click(event, self)
                elif self.mode == "debug":
                    debug_mode_handler.handle_debug_click(event, self)
        except StopIteration as e:
            running = e.value  # False if quit requested

        # Update hover state after processing events
        if running:
            if self.mode == "play":
                play_mode_handler.update_play_hover(self)
            elif self.mode == "debug":
                debug_mode_handler.update_debug_hover(self)

        return running

    def get_render_interaction_state(self) -> dict:
        """Returns interaction state needed by Visualizer.render"""
        return {
            "selected_shape_idx": self.selected_shape_idx,
            "hover_shape": self.hover_shape,
            "hover_grid_coord": self.hover_grid_coord,
            "hover_is_valid": self.hover_is_valid,
            "hover_screen_pos": self.mouse_pos,
            "debug_highlight_coord": self.debug_highlight_coord,
        }


File: src/trianglengin/ui/interaction/play_mode_handler.py
# src/trianglengin/ui/interaction/play_mode_handler.py
import logging
from typing import TYPE_CHECKING, cast

# Guard UI imports
try:
    import pygame

    # Use absolute import
    from trianglengin.ui.visualization import core as vis_core
except ImportError as e:
    raise ImportError(
        "UI components require 'pygame'. Install with 'pip install trianglengin[ui]'."
    ) from e

# Use absolute imports for core components
from trianglengin.config import EnvConfig

if TYPE_CHECKING:
    # Use absolute import for InputHandler as well
    from trianglengin.game_interface import GameState, Shape
    from trianglengin.ui.interaction.input_handler import InputHandler

logger = logging.getLogger(__name__)


# Add EnvConfig type hint for config
def _encode_action(shape_idx: int, r: int, c: int, config: EnvConfig) -> int:
    """Helper to encode action based on config. Matches C++ internal logic."""
    grid_size = config.ROWS * config.COLS
    if not (
        0 <= shape_idx < config.NUM_SHAPE_SLOTS
        and 0 <= r < config.ROWS
        and 0 <= c < config.COLS
    ):
        return -1
    # Cast the result to int for mypy
    return cast("int", shape_idx * grid_size + r * config.COLS + c)


def handle_play_click(event: pygame.event.Event, handler: "InputHandler") -> None:
    """Handles mouse clicks in play mode (select preview, place shape). Modifies handler state."""
    if not (event.type == pygame.MOUSEBUTTONDOWN and event.button == 1):
        return

    game_state: GameState = handler.game_state
    visualizer = handler.visualizer
    mouse_pos = handler.mouse_pos

    if game_state.is_over():
        logger.info("Game is over, ignoring click.")
        return

    layout_rects = visualizer.ensure_layout()
    grid_rect = layout_rects.get("grid")
    preview_rects = visualizer.preview_rects
    current_shapes = game_state.get_shapes()

    preview_idx = vis_core.coord_mapper.get_preview_index_from_screen(
        mouse_pos, preview_rects
    )
    if preview_idx is not None:
        if handler.selected_shape_idx == preview_idx:
            handler.selected_shape_idx = -1
            handler.hover_grid_coord = None
            handler.hover_shape = None
            logger.info("Deselected shape.")
        elif (
            0 <= preview_idx < len(current_shapes)
            and current_shapes[preview_idx] is not None
        ):
            handler.selected_shape_idx = preview_idx
            logger.info(f"Selected shape index: {preview_idx}")
            update_play_hover(handler)
        else:
            logger.info(f"Clicked empty/invalid preview slot: {preview_idx}")
            if handler.selected_shape_idx != -1:
                handler.selected_shape_idx = -1
                handler.hover_grid_coord = None
                handler.hover_shape = None
        return

    selected_idx = handler.selected_shape_idx
    if selected_idx != -1 and grid_rect and grid_rect.collidepoint(mouse_pos):
        grid_coords = vis_core.coord_mapper.get_grid_coords_from_screen(
            mouse_pos, grid_rect, game_state.env_config
        )
        shape_to_place: Shape | None = (
            current_shapes[selected_idx]
            if 0 <= selected_idx < len(current_shapes)
            else None
        )

        if grid_coords and shape_to_place:
            r, c = grid_coords
            potential_action = _encode_action(selected_idx, r, c, game_state.env_config)

            if (
                potential_action != -1
                and potential_action in game_state.valid_actions()
            ):
                reward, done = game_state.step(potential_action)
                logger.info(
                    f"Placed shape {selected_idx} at {grid_coords}. R={reward:.1f}, Done={done}"
                )
                handler.selected_shape_idx = -1
                handler.hover_grid_coord = None
                handler.hover_shape = None
            else:
                logger.info(
                    f"Clicked grid at {grid_coords}, but placement invalid (action {potential_action} not found in valid set)."
                )
        else:
            logger.info(f"Clicked grid at {grid_coords}, but shape or coords invalid.")


def update_play_hover(handler: "InputHandler") -> None:
    """Updates the hover state within the InputHandler."""
    handler.hover_grid_coord = None
    handler.hover_is_valid = False
    handler.hover_shape = None

    game_state: GameState = handler.game_state
    visualizer = handler.visualizer
    mouse_pos = handler.mouse_pos

    if game_state.is_over() or handler.selected_shape_idx == -1:
        return

    layout_rects = visualizer.ensure_layout()
    grid_rect = layout_rects.get("grid")
    selected_idx = handler.selected_shape_idx
    current_shapes = game_state.get_shapes()
    if not (0 <= selected_idx < len(current_shapes)):
        return
    shape: Shape | None = current_shapes[selected_idx]
    if not shape:
        return

    handler.hover_shape = shape

    if not grid_rect or not grid_rect.collidepoint(mouse_pos):
        return

    grid_coords = vis_core.coord_mapper.get_grid_coords_from_screen(
        mouse_pos, grid_rect, game_state.env_config
    )

    if grid_coords:
        r, c = grid_coords
        potential_action = _encode_action(selected_idx, r, c, game_state.env_config)
        is_valid = (
            potential_action != -1 and potential_action in game_state.valid_actions()
        )
        handler.hover_grid_coord = grid_coords
        handler.hover_is_valid = is_valid


File: src/trianglengin/ui/interaction/debug_mode_handler.py
# src/trianglengin/ui/interaction/debug_mode_handler.py
import logging
from typing import TYPE_CHECKING

# Imports are now direct
import pygame

# Use absolute imports for core components
from trianglengin.ui.visualization import core as vis_core

if TYPE_CHECKING:
    # Use absolute import for InputHandler as well
    from trianglengin.game_interface import GameState
    from trianglengin.ui.interaction.input_handler import InputHandler

logger = logging.getLogger(__name__)


def handle_debug_click(event: pygame.event.Event, handler: "InputHandler") -> None:
    """Handles mouse clicks in debug mode (toggle triangle state via C++)."""
    if not (event.type == pygame.MOUSEBUTTONDOWN and event.button == 1):
        return

    game_state: GameState = handler.game_state  # Type hint uses wrapper
    visualizer = handler.visualizer
    mouse_pos = handler.mouse_pos

    layout_rects = visualizer.ensure_layout()
    grid_rect = layout_rects.get("grid")
    if not grid_rect:
        logger.error("Grid layout rectangle not available for debug click.")
        return

    grid_coords = vis_core.coord_mapper.get_grid_coords_from_screen(
        mouse_pos, grid_rect, game_state.env_config
    )
    if not grid_coords:
        return

    r, c = grid_coords
    try:
        # Call the debug toggle method on the wrapper, which calls C++
        game_state.debug_toggle_cell(r, c)
        logger.debug(f"Debug: Toggled cell ({r},{c}) via C++ backend.")
    except Exception as e:
        logger.error(f"Error calling debug_toggle_cell for ({r},{c}): {e}")


def update_debug_hover(handler: "InputHandler") -> None:
    """Updates the debug highlight position within the InputHandler."""
    handler.debug_highlight_coord = None

    game_state: GameState = handler.game_state  # Type hint uses wrapper
    visualizer = handler.visualizer
    mouse_pos = handler.mouse_pos

    layout_rects = visualizer.ensure_layout()
    grid_rect = layout_rects.get("grid")
    if not grid_rect or not grid_rect.collidepoint(mouse_pos):
        return

    grid_coords = vis_core.coord_mapper.get_grid_coords_from_screen(
        mouse_pos, grid_rect, game_state.env_config
    )

    if grid_coords:
        r, c = grid_coords
        # Get grid data to check validity and death zone status
        grid_data_np = game_state.get_grid_data_np()
        rows, cols = grid_data_np["death"].shape
        if 0 <= r < rows and 0 <= c < cols and not grid_data_np["death"][r, c]:
            handler.debug_highlight_coord = grid_coords


File: src/trianglengin/core/__init__.py
# File: src/trianglengin/core/__init__.py
# This module is now significantly smaller.
# It might only contain the environment submodule placeholder if needed,
# or be empty if environment is fully represented by game_interface.
# Let's keep it minimal for now.

# No submodules left to export directly from here in the new structure.
# The main __init__.py exports the GameState interface.

__all__: list[str] = []  # No public exports from this level anymore


File: src/trianglengin/core/environment/shapes/templates.py
# File: src/trianglengin/core/environment/shapes/templates.py
# (No changes needed to this file content itself)
# File: trianglengin/core/environment/shapes/templates.py
# ==============================================================================
# ==                    PREDEFINED SHAPE TEMPLATES                          ==
# ==                                                                        ==
# ==    DO NOT MODIFY THIS LIST MANUALLY unless you are absolutely sure!    ==
# == These shapes are fundamental to the game's design and balance.         ==
# == Modifying them can have unintended consequences on gameplay and agent  ==
# == training.                                                              ==
# ==============================================================================

# List of predefined shape templates. Each template is a list of relative triangle coordinates (dr, dc, is_up).
# Coordinates are relative to the shape's origin (typically the top-leftmost triangle).
# is_up = True for upward-pointing triangle, False for downward-pointing.
PREDEFINED_SHAPE_TEMPLATES: list[list[tuple[int, int, bool]]] = [
    [  # Shape 1
        (
            0,
            0,
            True,
        )
    ],
    [  # Shape 1
        (
            0,
            0,
            True,
        )
    ],
    [  # Shape 2
        (
            0,
            0,
            True,
        ),
        (
            1,
            0,
            False,
        ),
    ],
    [  # Shape 2
        (
            0,
            0,
            True,
        ),
        (
            1,
            0,
            False,
        ),
    ],
    [  # Shape 3
        (
            0,
            0,
            False,
        )
    ],
    [  # Shape 4
        (
            0,
            0,
            True,
        ),
        (
            0,
            1,
            False,
        ),
    ],
    [  # Shape 4
        (
            0,
            0,
            True,
        ),
        (
            0,
            1,
            False,
        ),
    ],
    [  # Shape 5
        (
            0,
            0,
            False,
        ),
        (
            0,
            1,
            True,
        ),
    ],
    [  # Shape 5
        (
            0,
            0,
            False,
        ),
        (
            0,
            1,
            True,
        ),
    ],
    [  # Shape 6
        (
            0,
            0,
            True,
        ),
        (
            0,
            1,
            False,
        ),
        (
            0,
            2,
            True,
        ),
    ],
    [  # Shape 7
        (
            0,
            0,
            False,
        ),
        (
            0,
            1,
            True,
        ),
        (
            0,
            2,
            False,
        ),
    ],
    [  # Shape 8
        (
            0,
            0,
            True,
        ),
        (
            0,
            1,
            False,
        ),
        (
            0,
            2,
            True,
        ),
        (
            1,
            0,
            False,
        ),
    ],
    [  # Shape 9
        (
            0,
            0,
            True,
        ),
        (
            0,
            1,
            False,
        ),
        (
            0,
            2,
            True,
        ),
        (
            1,
            2,
            False,
        ),
    ],
    [  # Shape 10
        (
            0,
            0,
            False,
        ),
        (
            0,
            1,
            True,
        ),
        (
            1,
            0,
            True,
        ),
        (
            1,
            1,
            False,
        ),
    ],
    [  # Shape 11
        (
            0,
            0,
            True,
        ),
        (
            0,
            2,
            True,
        ),
        (
            1,
            0,
            False,
        ),
        (
            1,
            1,
            True,
        ),
        (
            1,
            2,
            False,
        ),
    ],
    [  # Shape 12
        (
            0,
            0,
            True,
        ),
        (
            1,
            -2,
            False,
        ),
        (
            1,
            -1,
            True,
        ),
        (
            1,
            0,
            False,
        ),
    ],
    [  # Shape 13
        (
            0,
            0,
            True,
        ),
        (
            0,
            1,
            False,
        ),
        (
            1,
            0,
            False,
        ),
        (
            1,
            1,
            True,
        ),
    ],
    [  # Shape 14
        (
            0,
            0,
            True,
        ),
        (
            0,
            1,
            False,
        ),
        (
            1,
            0,
            False,
        ),
        (
            1,
            1,
            True,
        ),
        (
            1,
            2,
            False,
        ),
    ],
    [  # Shape 15
        (
            0,
            0,
            True,
        ),
        (
            0,
            1,
            False,
        ),
        (
            0,
            2,
            True,
        ),
        (
            1,
            0,
            False,
        ),
        (
            1,
            1,
            True,
        ),
    ],
    [  # Shape 16
        (
            0,
            0,
            True,
        ),
        (
            0,
            1,
            False,
        ),
        (
            0,
            2,
            True,
        ),
        (
            1,
            0,
            False,
        ),
        (
            1,
            2,
            False,
        ),
    ],
    [  # Shape 17
        (
            0,
            0,
            True,
        ),
        (
            0,
            1,
            False,
        ),
        (
            0,
            2,
            True,
        ),
        (
            1,
            1,
            True,
        ),
        (
            1,
            2,
            False,
        ),
    ],
    [  # Shape 18
        (
            0,
            0,
            True,
        ),
        (
            0,
            2,
            True,
        ),
        (
            1,
            0,
            False,
        ),
        (
            1,
            1,
            True,
        ),
        (
            1,
            2,
            False,
        ),
    ],
    [  # Shape 19
        (
            0,
            0,
            True,
        ),
        (
            0,
            1,
            False,
        ),
        (
            1,
            0,
            False,
        ),
        (
            1,
            1,
            True,
        ),
        (
            1,
            2,
            False,
        ),
    ],
    [  # Shape 20
        (
            0,
            0,
            False,
        ),
        (
            0,
            1,
            True,
        ),
        (
            1,
            1,
            False,
        ),
    ],
    [  # Shape 21
        (
            0,
            0,
            True,
        ),
        (
            1,
            -1,
            True,
        ),
        (
            1,
            0,
            False,
        ),
    ],
    [  # Shape 22
        (
            0,
            0,
            True,
        ),
        (
            1,
            0,
            False,
        ),
        (
            1,
            1,
            True,
        ),
    ],
    [  # Shape 23
        (
            0,
            0,
            True,
        ),
        (
            1,
            -1,
            True,
        ),
        (
            1,
            0,
            False,
        ),
        (
            1,
            1,
            True,
        ),
    ],
    [  # Shape 24
        (
            0,
            0,
            True,
        ),
        (
            1,
            -1,
            True,
        ),
        (
            1,
            0,
            False,
        ),
    ],
    [  # Shape 25
        (
            0,
            0,
            False,
        ),
        (
            0,
            1,
            True,
        ),
        (
            0,
            2,
            False,
        ),
        (
            1,
            1,
            False,
        ),
    ],
    [  # Shape 26
        (
            0,
            0,
            False,
        ),
        (
            0,
            1,
            True,
        ),
        (
            1,
            1,
            False,
        ),
    ],
    [  # Shape 27
        (
            0,
            0,
            True,
        ),
        (
            0,
            1,
            False,
        ),
        (
            1,
            0,
            False,
        ),
    ],
]


File: src/trianglengin/config/display_config.py
# trianglengin/config/display_config.py
"""
Configuration specific to display and visualization settings.
"""

import pygame
from pydantic import BaseModel, Field

# Initialize Pygame font module if not already done (safe to call multiple times)
pygame.font.init()

# Define a placeholder font loading function or load directly here
# In a real app, this might load from files or use system fonts more robustly.
try:
    DEBUG_FONT_DEFAULT = pygame.font.SysFont("monospace", 12)
except Exception:
    DEBUG_FONT_DEFAULT = pygame.font.Font(None, 15)  # Fallback default pygame font


class DisplayConfig(BaseModel):
    """Configuration for visualization display settings."""

    # Screen and Layout
    SCREEN_WIDTH: int = Field(default=1024, gt=0)
    SCREEN_HEIGHT: int = Field(default=768, gt=0)
    FPS: int = Field(default=60, gt=0)
    PADDING: int = Field(default=10, ge=0)
    HUD_HEIGHT: int = Field(default=30, ge=0)
    PREVIEW_AREA_WIDTH: int = Field(default=150, ge=50)
    PREVIEW_PADDING: int = Field(default=5, ge=0)
    PREVIEW_INNER_PADDING: int = Field(default=3, ge=0)
    PREVIEW_BORDER_WIDTH: int = Field(default=1, ge=0)
    PREVIEW_SELECTED_BORDER_WIDTH: int = Field(default=3, ge=0)

    # Fonts (Store font objects directly or paths/names)
    # Using Field(default=...) requires the default value to be simple.
    # For complex objects like fonts, use default_factory or initialize in __init__.
    # For simplicity here, we'll assign the pre-loaded font.
    # Consider using default_factory=lambda: pygame.font.SysFont(...)
    DEBUG_FONT: pygame.font.Font = Field(default=DEBUG_FONT_DEFAULT)

    class Config:
        arbitrary_types_allowed = True  # Allow pygame.font.Font


# Optional: Create a default instance for easy import elsewhere
DEFAULT_DISPLAY_CONFIG = DisplayConfig()


File: src/trianglengin/config/env_config.py
# File: src/trianglengin/config/env_config.py

from pydantic import BaseModel, Field, ValidationInfo, field_validator, model_validator


class EnvConfig(BaseModel):
    """Configuration for the game environment (Pydantic model)."""

    ROWS: int = Field(default=8, gt=0)
    COLS: int = Field(default=15, gt=0)
    PLAYABLE_RANGE_PER_ROW: list[tuple[int, int]] = Field(  # Use List, Tuple
        default=[(3, 12), (2, 13), (1, 14), (0, 15), (0, 15), (1, 14), (2, 13), (3, 12)]
    )
    NUM_SHAPE_SLOTS: int = Field(default=3, gt=0)

    REWARD_PER_PLACED_TRIANGLE: float = Field(default=0.01)
    REWARD_PER_CLEARED_TRIANGLE: float = Field(default=0.5)
    REWARD_PER_STEP_ALIVE: float = Field(default=0.005)
    PENALTY_GAME_OVER: float = Field(default=-10.0)

    @field_validator("PLAYABLE_RANGE_PER_ROW")
    @classmethod
    def check_playable_range_length(
        cls,
        v: list[tuple[int, int]],
        info: ValidationInfo,  # Use List, Tuple
    ) -> list[tuple[int, int]]:  # Use List, Tuple
        """Validates PLAYABLE_RANGE_PER_ROW."""
        rows = info.data.get("ROWS")
        cols = info.data.get("COLS")

        if rows is None or cols is None:
            return v

        if len(v) != rows:
            raise ValueError(
                f"PLAYABLE_RANGE_PER_ROW length ({len(v)}) must equal ROWS ({rows})"
            )

        for i, (start, end) in enumerate(v):
            if not (0 <= start <= cols):
                raise ValueError(
                    f"Row {i}: start_col ({start}) out of bounds [0, {cols}]."
                )
            if not (start <= end <= cols):
                raise ValueError(
                    f"Row {i}: end_col ({end}) invalid. Must be >= start_col ({start}) and <= COLS ({cols})."
                )
        return v

    @model_validator(mode="after")
    def check_cols_sufficient_for_ranges(self) -> "EnvConfig":
        """Ensure COLS is large enough for the specified ranges."""
        if hasattr(self, "PLAYABLE_RANGE_PER_ROW") and self.PLAYABLE_RANGE_PER_ROW:
            max_end_col = max(
                (end for _, end in self.PLAYABLE_RANGE_PER_ROW), default=0
            )
            if max_end_col > self.COLS:
                raise ValueError(
                    f"COLS ({self.COLS}) must be >= max end_col ({max_end_col})"
                )
        return self


File: src/trianglengin/config/__init__.py
# trianglengin/config/__init__.py
"""
Shared configuration models for the Triangle Engine core.
"""

from .env_config import EnvConfig

__all__ = ["EnvConfig"]


File: src/trianglengin/config/README.md


# Core Configuration Module (`trianglengin.config`)

## Purpose

This module defines the core configuration settings for the `trianglengin` game engine, independent of any UI components.

-   **[`env_config.py`](env_config.py):** Defines the `EnvConfig` Pydantic model. This class holds parameters crucial to the game simulation itself, such as:
    -   Grid dimensions (`ROWS`, `COLS`).
    -   Playable area definition (`PLAYABLE_RANGE_PER_ROW`).
    -   Number of shape preview slots (`NUM_SHAPE_SLOTS`).
    -   Reward/penalty values used by the C++ engine (`REWARD_PER_PLACED_TRIANGLE`, `REWARD_PER_CLEARED_TRIANGLE`, `REWARD_PER_STEP_ALIVE`, `PENALTY_GAME_OVER`).

## Usage

An instance of `EnvConfig` is typically created and passed to the `trianglengin.game_interface.GameState` wrapper during initialization. The wrapper then passes these settings to the underlying C++ engine.

```python
from trianglengin import GameState, EnvConfig

# Use default configuration
default_config = EnvConfig()
game = GameState(config=default_config)

# Use custom configuration
custom_config = EnvConfig(ROWS=10, COLS=10, PLAYABLE_RANGE_PER_ROW=[(0,10)]*10)
custom_game = GameState(config=custom_config)
```

## Dependencies

-   **`pydantic`**: Used for data validation and settings management.
-   **Standard Libraries:** `typing`.

---

**Note:** Configuration related to display or interactive UI elements (like screen size, FPS, fonts) is handled separately in the optional `trianglengin.ui.config` module.


File: src/trianglengin/utils/__init__.py
"""
General utilities for the Triangle Engine.
"""

# --- ADDED: Export geometry ---
from . import geometry
from .types import ActionType

__all__ = ["ActionType", "geometry"]


File: src/trianglengin/utils/types.py
# File: trianglengin/trianglengin/utils/types.py
# Placeholder for Phase 1
"""
Shared type definitions for the Triangle Engine.
"""

from typing import TypeAlias

# Action representation (integer index)
ActionType: TypeAlias = int


File: src/trianglengin/utils/geometry.py
# File: src/trianglengin/utils/geometry.py
from collections.abc import Sequence  # Import Tuple


def is_point_in_polygon(
    point: tuple[float, float], polygon: Sequence[tuple[float, float]]
) -> bool:
    """
    Checks if a point is inside a polygon using the Winding Number algorithm.
    Handles points on the boundary correctly.

    Args:
        point: Tuple (x, y) representing the point coordinates.
        polygon: Sequence of tuples [(x1, y1), (x2, y2), ...] representing polygon vertices in order.

    Returns:
        True if the point is inside or on the boundary of the polygon, False otherwise.
    """
    x, y = point
    n = len(polygon)
    if n < 3:
        return False

    wn = 0
    epsilon = 1e-9

    for i in range(n):
        p1 = polygon[i]
        p2 = polygon[(i + 1) % n]

        if abs(p1[0] - x) < epsilon and abs(p1[1] - y) < epsilon:
            return True
        if (
            abs(p1[1] - p2[1]) < epsilon
            and abs(p1[1] - y) < epsilon
            and min(p1[0], p2[0]) - epsilon <= x <= max(p1[0], p2[0]) + epsilon
        ):
            return True
        if (
            abs(p1[0] - p2[0]) < epsilon
            and abs(p1[0] - x) < epsilon
            and min(p1[1], p2[1]) - epsilon <= y <= max(p1[1], p2[1]) + epsilon
        ):
            return True

        y_in_upward_range = p1[1] <= y + epsilon < p2[1] + epsilon
        y_in_downward_range = p2[1] <= y + epsilon < p1[1] + epsilon

        if y_in_upward_range or y_in_downward_range:
            orientation = (p2[0] - p1[0]) * (y - p1[1]) - (x - p1[0]) * (p2[1] - p1[1])
            if y_in_upward_range and orientation > epsilon:
                wn += 1
            elif y_in_downward_range and orientation < -epsilon:
                wn -= 1
            elif (
                abs(orientation) < epsilon
                and min(p1[0], p2[0]) - epsilon <= x <= max(p1[0], p2[0]) + epsilon
                and min(p1[1], p2[1]) - epsilon <= y <= max(p1[1], p2[1]) + epsilon
            ):
                return True

    return wn != 0


File: src/trianglengin/cpp/CMakeLists.txt

cmake_minimum_required(VERSION 3.14)
project(trianglengin_cpp LANGUAGES CXX)

# Locate Pybind11 using variables passed from setup.py (pybind11_DIR)
find_package(pybind11 CONFIG REQUIRED)

# Sources
set(TRIANGLENGIN_SOURCES
    bindings.cpp
    game_state.cpp
    grid_data.cpp
    grid_logic.cpp
    shape_logic.cpp
    # Add other .cpp files if needed
)

# Build the pybind11 module
pybind11_add_module(trianglengin_cpp MODULE ${TRIANGLENGIN_SOURCES})

# C++17 Standard
target_compile_features(trianglengin_cpp PRIVATE cxx_std_17)

# Include directories (current source dir for headers)
target_include_directories(trianglengin_cpp PRIVATE ${CMAKE_CURRENT_SOURCE_DIR})

# Optimisation flags and visibility
if(MSVC)
  target_compile_options(trianglengin_cpp PRIVATE /O2 /W4) # Add warning level
else()
  target_compile_options(trianglengin_cpp PRIVATE -O3 -DNDEBUG -Wall -Wextra -pedantic) # Add warnings
  # Symbol visibility for non-Apple Unix-like systems
  if(NOT APPLE)
    target_compile_options(trianglengin_cpp PRIVATE -fvisibility=hidden)
  endif()
endif()

# Output directory is set via CMAKE_LIBRARY_OUTPUT_DIRECTORY in setup.py

# --- Status Messages ---
message(STATUS "pybind11 Include Dirs: ${pybind11_INCLUDE_DIRS}")
message(STATUS "Building C++ extension for Trianglengin version ${TRIANGLENGIN_VERSION_INFO}")


File: src/trianglengin/cpp/config.h
// File: src/trianglengin/cpp/config.h
#ifndef TRIANGLENGIN_CPP_CONFIG_H
#define TRIANGLENGIN_CPP_CONFIG_H

#pragma once

#include <vector>
#include <tuple>
#include <cstdint>

namespace trianglengin::cpp
{
  struct EnvConfigCpp
  {
    int rows = 8;
    int cols = 15;
    std::vector<std::tuple<int, int>> playable_range_per_row = {
        {3, 12}, {2, 13}, {1, 14}, {0, 15}, {0, 15}, {1, 14}, {2, 13}, {3, 12}};
    int num_shape_slots = 3;
    double reward_per_placed_triangle = 0.01;
    double reward_per_cleared_triangle = 0.5;
    double reward_per_step_alive = 0.005;
    double penalty_game_over = -10.0;
    int action_dim = 0;
  };
} // namespace trianglengin::cpp

#endif // TRIANGLENGIN_CPP_CONFIG_H

File: src/trianglengin/cpp/grid_data.cpp
// File: src/trianglengin/cpp/grid_data.cpp
#include "grid_data.h"
#include <stdexcept>
#include <set>
#include <algorithm>
#include <iostream>

namespace trianglengin::cpp
{

  // Constructor: Initialize config_ by copying the passed config
  GridData::GridData(const EnvConfigCpp &config)
      : config_(config), // Copy config here
        rows_(config_.rows),
        cols_(config_.cols)
  {
    if (rows_ <= 0 || cols_ <= 0)
    {
      throw std::invalid_argument("Grid dimensions must be positive.");
    }
    occupied_grid_.assign(rows_, std::vector<bool>(cols_, false));
    color_id_grid_.assign(rows_, std::vector<int8_t>(cols_, NO_COLOR_ID));
    death_grid_.assign(rows_, std::vector<bool>(cols_, true));

    if (config_.playable_range_per_row.size() != static_cast<size_t>(rows_))
    {
      throw std::invalid_argument("Playable range size mismatch with rows.");
    }
    for (int r = 0; r < rows_; ++r)
    {
      const auto &[start_col, end_col] = config_.playable_range_per_row[r];
      if (start_col < 0 || end_col > cols_ || start_col > end_col) // Allow start == end
      {
        throw std::invalid_argument("Invalid playable range for row " + std::to_string(r));
      }
      if (start_col < end_col)
      {
        for (int c = start_col; c < end_col; ++c)
        {
          death_grid_[r][c] = false;
        }
      }
    }
    precompute_lines();
  }

  // Copy constructor: Copy the config_ member
  GridData::GridData(const GridData &other)
      : config_(other.config_), // Copy config value
        rows_(other.rows_),
        cols_(other.cols_),
        occupied_grid_(other.occupied_grid_),
        color_id_grid_(other.color_id_grid_),
        death_grid_(other.death_grid_),
        lines_(other.lines_),
        coord_to_lines_map_(other.coord_to_lines_map_)
  {
  }

  // Copy assignment operator: Copy the config_ member
  GridData &GridData::operator=(const GridData &other)
  {
    if (this != &other)
    {
      config_ = other.config_; // Copy config value
      rows_ = other.rows_;
      cols_ = other.cols_;
      occupied_grid_ = other.occupied_grid_;
      color_id_grid_ = other.color_id_grid_;
      death_grid_ = other.death_grid_;
      lines_ = other.lines_;
      coord_to_lines_map_ = other.coord_to_lines_map_;
    }
    return *this;
  }

  void GridData::reset()
  {
    for (int r = 0; r < rows_; ++r)
    {
      std::fill(occupied_grid_[r].begin(), occupied_grid_[r].end(), false);
      std::fill(color_id_grid_[r].begin(), color_id_grid_[r].end(), NO_COLOR_ID);
    }
  }

  bool GridData::is_valid(int r, int c) const
  {
    return r >= 0 && r < rows_ && c >= 0 && c < cols_;
  }

  bool GridData::is_death(int r, int c) const
  {
    if (!is_valid(r, c))
    {
      throw std::out_of_range("Coordinates (" + std::to_string(r) + "," + std::to_string(c) + ") out of bounds.");
    }
    return death_grid_[r][c];
  }

  bool GridData::is_occupied(int r, int c) const
  {
    if (!is_valid(r, c))
    {
      throw std::out_of_range("Coordinates (" + std::to_string(r) + "," + std::to_string(c) + ") out of bounds.");
    }
    return !death_grid_[r][c] && occupied_grid_[r][c];
  }

  std::optional<int> GridData::get_color_id(int r, int c) const
  {
    if (!is_valid(r, c) || death_grid_[r][c] || !occupied_grid_[r][c])
    {
      return std::nullopt;
    }
    return color_id_grid_[r][c];
  }

  bool GridData::is_up(int r, int c) const
  {
    return (r + c) % 2 != 0;
  }

  bool GridData::is_live(int r, int c) const
  {
    return is_valid(r, c) && !death_grid_[r][c];
  }

  std::optional<Coord> GridData::get_neighbor(int r, int c, const std::string &direction, bool backward) const
  {
    bool up = is_up(r, c);
    int nr = -1, nc = -1;

    if (direction == "h")
    {
      int dc = backward ? -1 : 1;
      nr = r;
      nc = c + dc;
    }
    else if (direction == "d1")
    { // TL-BR
      if (backward)
      {
        nr = up ? r : r - 1;
        nc = up ? c - 1 : c;
      }
      else
      {
        nr = up ? r + 1 : r;
        nc = up ? c : c + 1;
      }
    }
    else if (direction == "d2")
    { // BL-TR
      if (backward)
      {
        nr = up ? r + 1 : r;
        nc = up ? c : c - 1;
      }
      else
      {
        nr = up ? r : r - 1;
        nc = up ? c + 1 : c;
      }
    }
    else
    {
      throw std::invalid_argument("Unknown direction: " + direction);
    }

    if (!is_valid(nr, nc))
      return std::nullopt;
    return Coord{nr, nc};
  }

  void GridData::precompute_lines()
  {
    lines_.clear();
    coord_to_lines_map_.clear();
    std::set<Line> maximal_lines_set;
    std::set<std::tuple<Coord, std::string>> processed_starts;
    const std::vector<std::string> directions = {"h", "d1", "d2"};

    for (int r_init = 0; r_init < rows_; ++r_init)
    {
      for (int c_init = 0; c_init < cols_; ++c_init)
      {
        if (!is_live(r_init, c_init))
          continue;
        Coord start_coord = {r_init, c_init};
        for (const auto &direction : directions)
        {
          Coord line_start_coord = start_coord;
          while (true)
          {
            auto prev_coord_opt = get_neighbor(std::get<0>(line_start_coord), std::get<1>(line_start_coord), direction, true);
            if (prev_coord_opt && is_live(std::get<0>(*prev_coord_opt), std::get<1>(*prev_coord_opt)))
            {
              line_start_coord = *prev_coord_opt;
            }
            else
              break;
          }
          if (processed_starts.count({line_start_coord, direction}))
            continue;
          Line current_line;
          std::optional<Coord> trace_coord_opt = line_start_coord;
          while (trace_coord_opt && is_live(std::get<0>(*trace_coord_opt), std::get<1>(*trace_coord_opt)))
          {
            current_line.push_back(*trace_coord_opt);
            trace_coord_opt = get_neighbor(std::get<0>(*trace_coord_opt), std::get<1>(*trace_coord_opt), direction, false);
          }
          if (current_line.size() >= 2)
          {
            maximal_lines_set.insert(current_line);
            processed_starts.insert({line_start_coord, direction});
          }
        }
      }
    }

    lines_ = std::vector<Line>(maximal_lines_set.begin(), maximal_lines_set.end());
    std::sort(lines_.begin(), lines_.end(), [](const Line &a, const Line &b)
              {
            if (a.empty() || b.empty()) return b.empty();
            if (std::get<0>(a[0]) != std::get<0>(b[0])) return std::get<0>(a[0]) < std::get<0>(b[0]);
            if (std::get<1>(a[0]) != std::get<1>(b[0])) return std::get<1>(a[0]) < std::get<1>(b[0]);
            return a.size() < b.size(); });

    for (const auto &line_vec : lines_)
    {
      LineFs line_fs(line_vec.begin(), line_vec.end());
      for (const auto &coord : line_vec)
      {
        coord_to_lines_map_[coord].insert(line_fs);
      }
    }
  }

} // namespace trianglengin::cpp

File: src/trianglengin/cpp/grid_data.h
// File: src/trianglengin/cpp/grid_data.h
#ifndef TRIANGLENGIN_CPP_GRID_DATA_H
#define TRIANGLENGIN_CPP_GRID_DATA_H

#pragma once

#include <vector>
#include <set>
#include <map>
#include <tuple>
#include <memory>
#include <optional>
#include <string>
#include <stdexcept>

#include "config.h"
#include "structs.h"

namespace trianglengin::cpp
{
  using Line = std::vector<Coord>;
  using LineFs = std::set<Coord>;
  using LineFsSet = std::set<LineFs>;
  using CoordMap = std::map<Coord, LineFsSet>;

  class GridData
  {
  public:
    // Constructor takes config by const reference but stores by value
    explicit GridData(const EnvConfigCpp &config);

    void reset();
    bool is_valid(int r, int c) const;
    bool is_death(int r, int c) const;
    bool is_occupied(int r, int c) const;
    std::optional<int> get_color_id(int r, int c) const;
    bool is_up(int r, int c) const;

    const std::vector<std::vector<bool>> &get_occupied_grid() const { return occupied_grid_; }
    const std::vector<std::vector<int8_t>> &get_color_id_grid() const { return color_id_grid_; }
    const std::vector<std::vector<bool>> &get_death_grid() const { return death_grid_; }
    std::vector<std::vector<bool>> &get_occupied_grid_mut() { return occupied_grid_; }
    std::vector<std::vector<int8_t>> &get_color_id_grid_mut() { return color_id_grid_; }

    const std::vector<Line> &get_lines() const { return lines_; }
    const CoordMap &get_coord_to_lines_map() const { return coord_to_lines_map_; }

    int rows() const { return rows_; }
    int cols() const { return cols_; }

    // Copy constructor
    GridData(const GridData &other);
    // Copy assignment operator
    GridData &operator=(const GridData &other);

    // Default move constructor/assignment should work now
    GridData(GridData &&other) noexcept = default;
    GridData &operator=(GridData &&other) noexcept = default;

  private:
    EnvConfigCpp config_; // Store config by value now
    int rows_;
    int cols_;
    std::vector<std::vector<bool>> occupied_grid_;
    std::vector<std::vector<int8_t>> color_id_grid_;
    std::vector<std::vector<bool>> death_grid_;

    std::vector<Line> lines_;
    CoordMap coord_to_lines_map_;

    void precompute_lines();
    bool is_live(int r, int c) const;
    std::optional<Coord> get_neighbor(int r, int c, const std::string &direction, bool backward) const;
  };

} // namespace trianglengin::cpp

#endif // TRIANGLENGIN_CPP_GRID_DATA_H


File: src/trianglengin/cpp/game_state.h
// File: src/trianglengin/cpp/game_state.h
#ifndef TRIANGLENGIN_CPP_GAME_STATE_H
#define TRIANGLENGIN_CPP_GAME_STATE_H

#pragma once

#include <vector>
#include <set>
#include <optional>
#include <random>
#include <memory>
#include <string> // Include string for optional<string>
#include <tuple>  // Include tuple for std::tuple

#include "config.h"
#include "structs.h"
#include "grid_data.h"
// Remove direct includes causing cycles if possible, use forward declarations
// #include "grid_logic.h" // Included by game_state.cpp
// #include "shape_logic.h" // Included by game_state.cpp

namespace trianglengin::cpp
{

  class GameStateCpp
  {
  public:
    explicit GameStateCpp(const EnvConfigCpp &config, unsigned int initial_seed);

    void reset();
    std::tuple<double, bool> step(Action action);
    bool is_over() const;
    double get_score() const;
    const std::set<Action> &get_valid_actions(bool force_recalculate = false);
    int get_current_step() const;
    std::optional<std::string> get_game_over_reason() const;
    GameStateCpp copy() const;
    void debug_toggle_cell(int r, int c);
    void invalidate_action_cache(); // Moved to public
    // Debug method to force shapes into slots
    void debug_set_shapes(const std::vector<std::optional<ShapeCpp>> &new_shapes);

    // Accessors needed by logic functions or bindings
    const GridData &get_grid_data() const { return grid_data_; }
    GridData &get_grid_data_mut() { return grid_data_; }
    const std::vector<std::optional<ShapeCpp>> &get_shapes() const { return shapes_; }
    std::vector<std::optional<ShapeCpp>> &get_shapes_mut() { return shapes_; }
    const EnvConfigCpp &get_config() const { return config_; }

  private:
    EnvConfigCpp config_;
    GridData grid_data_;
    std::vector<std::optional<ShapeCpp>> shapes_;
    double score_;
    int current_step_;
    bool game_over_;
    std::optional<std::string> game_over_reason_;
    mutable std::optional<std::set<Action>> valid_actions_cache_; // Mutable for const getter
    std::mt19937 rng_;

    void check_initial_state_game_over();
    void force_game_over(const std::string &reason);
    // void invalidate_action_cache(); // Moved from private
    void calculate_valid_actions_internal() const; // Made const

    // Action encoding/decoding (can be private if only used internally)
    Action encode_action(int shape_idx, int r, int c) const;
    std::tuple<int, int, int> decode_action(Action action) const;
  };

} // namespace trianglengin::cpp

#endif // TRIANGLENGIN_CPP_GAME_STATE_H

File: src/trianglengin/cpp/game_state.cpp
// File: src/trianglengin/cpp/game_state.cpp
#include "game_state.h"
#include "grid_logic.h"
#include "shape_logic.h"
#include <stdexcept>
#include <numeric>
#include <iostream>  // Keep iostream if other debug logs might be added later, or remove if not needed
#include <algorithm> // For std::min

namespace trianglengin::cpp
{

  GameStateCpp::GameStateCpp(const EnvConfigCpp &config, unsigned int initial_seed)
      : config_(config),
        grid_data_(config_),
        shapes_(config_.num_shape_slots),
        score_(0.0),
        current_step_(0),
        game_over_(false),
        rng_(initial_seed)
  {
    reset();
  }

  void GameStateCpp::reset()
  {
    grid_data_.reset();
    std::fill(shapes_.begin(), shapes_.end(), std::nullopt);
    score_ = 0.0;
    current_step_ = 0;
    game_over_ = false;
    game_over_reason_ = std::nullopt;
    valid_actions_cache_ = std::nullopt;
    shape_logic::refill_shape_slots(*this, rng_);
    check_initial_state_game_over();
  }

  void GameStateCpp::check_initial_state_game_over()
  {
    get_valid_actions(true); // This calls calculate_valid_actions_internal
    if (!game_over_ && valid_actions_cache_ && valid_actions_cache_->empty())
    {
      force_game_over("No valid actions available at start.");
      // REMOVED C++ Log: std::cerr << "[GameStateCpp::check_initial_state_game_over] Forced game over: No valid actions at start." << std::endl;
    }
  }

  std::tuple<double, bool> GameStateCpp::step(Action action)
  {
    if (game_over_)
    {
      return {0.0, true};
    }

    const auto &valid_actions = get_valid_actions();
    if (valid_actions.find(action) == valid_actions.end())
    {
      // Invalid action detected
      force_game_over("Invalid action provided: " + std::to_string(action));
      // Apply penalty to score *before* returning
      score_ += config_.penalty_game_over;
      return {config_.penalty_game_over, true}; // Return penalty and done=true
    }

    int shape_idx, r, c;
    try
    {
      std::tie(shape_idx, r, c) = decode_action(action);
    }
    catch (const std::out_of_range &e)
    {
      // Error during decoding (should be caught by valid_actions check, but defensive)
      force_game_over("Failed to decode action: " + std::to_string(action));
      score_ += config_.penalty_game_over; // Apply penalty
      return {config_.penalty_game_over, true};
    }

    if (shape_idx < 0 || shape_idx >= static_cast<int>(shapes_.size()) || !shapes_[shape_idx].has_value())
    {
      // Action references invalid slot (should be caught by valid_actions check)
      force_game_over("Action references invalid/empty shape slot: " + std::to_string(shape_idx));
      score_ += config_.penalty_game_over; // Apply penalty
      return {config_.penalty_game_over, true};
    }

    const ShapeCpp &shape_to_place = shapes_[shape_idx].value();

    if (!grid_logic::can_place(grid_data_, shape_to_place, r, c))
    {
      // Should not happen if valid_actions is correct
      force_game_over("Placement check failed for valid action (logic error?). Action: " + std::to_string(action));
      score_ += config_.penalty_game_over; // Apply penalty
      return {config_.penalty_game_over, true};
    }

    // --- Placement ---
    std::set<Coord> newly_occupied_coords;
    int placed_count = 0;
    auto &occupied_grid = grid_data_.get_occupied_grid_mut();
    auto &color_grid = grid_data_.get_color_id_grid_mut();
    for (const auto &tri_data : shape_to_place.triangles)
    {
      int dr, dc;
      bool is_up_ignored;
      std::tie(dr, dc, is_up_ignored) = tri_data;
      int target_r = r + dr;
      int target_c = c + dc;
      if (!grid_data_.is_valid(target_r, target_c) || grid_data_.is_death(target_r, target_c))
      {
        force_game_over("Attempted placement out of bounds/death zone during execution. Action: " + std::to_string(action));
        score_ += config_.penalty_game_over; // Apply penalty
        return {config_.penalty_game_over, true};
      }
      occupied_grid[target_r][target_c] = true;
      color_grid[target_r][target_c] = static_cast<int8_t>(shape_to_place.color_id);
      newly_occupied_coords.insert({target_r, target_c});
      placed_count++;
    }
    shapes_[shape_idx] = std::nullopt;

    // --- Line Clearing ---
    int lines_cleared_count;
    std::set<Coord> cleared_coords;
    LineFsSet cleared_lines_fs;
    std::tie(lines_cleared_count, cleared_coords, cleared_lines_fs) =
        grid_logic::check_and_clear_lines(grid_data_, newly_occupied_coords);
    int cleared_count = static_cast<int>(cleared_coords.size());

    // --- Refill ---
    bool all_slots_empty = true;
    for (const auto &shape_opt : shapes_)
    {
      if (shape_opt.has_value())
      {
        all_slots_empty = false;
        break;
      }
    }
    if (all_slots_empty)
    {
      shape_logic::refill_shape_slots(*this, rng_);
    }

    // --- Update State & Check Game Over ---
    current_step_++;
    valid_actions_cache_ = std::nullopt;
    get_valid_actions(true); // Force recalculation and update game_over_ if needed
    // game_over_ flag is now definitive

    // --- Calculate Reward & Update Score ---
    double reward = 0.0;
    reward += static_cast<double>(placed_count) * config_.reward_per_placed_triangle;
    reward += static_cast<double>(cleared_count) * config_.reward_per_cleared_triangle;

    if (game_over_)
    {
      reward += config_.penalty_game_over;
    }
    else
    {
      reward += config_.reward_per_step_alive;
    }
    score_ += reward; // Update score based on calculated reward

    return {reward, game_over_};
  }

  bool GameStateCpp::is_over() const
  {
    if (game_over_)
      return true;
    // If cache exists, use it. Otherwise, calculate.
    if (valid_actions_cache_.has_value())
      return valid_actions_cache_->empty();
    // Need to remove const to calculate and potentially set game_over_
    const_cast<GameStateCpp *>(this)->calculate_valid_actions_internal();
    // Check game_over_ again as calculate might have set it
    if (game_over_)
      return true;
    // Now the cache should exist
    return valid_actions_cache_->empty();
  }

  void GameStateCpp::force_game_over(const std::string &reason)
  {
    // This function only sets the flags and reason.
    // Score update should happen in the context where the game over is triggered (e.g., step).
    if (!game_over_)
    {
      game_over_ = true;
      game_over_reason_ = reason;
      valid_actions_cache_ = std::set<Action>();
    }
  }

  double GameStateCpp::get_score() const
  {
    return score_;
  }

  const std::set<Action> &GameStateCpp::get_valid_actions(bool force_recalculate)
  {
    if (game_over_)
    {
      if (!valid_actions_cache_.has_value() || !valid_actions_cache_->empty())
      {
        valid_actions_cache_ = std::set<Action>();
      }
      return *valid_actions_cache_;
    }
    if (!force_recalculate && valid_actions_cache_.has_value())
    {
      return *valid_actions_cache_;
    }
    calculate_valid_actions_internal();
    // Check if game should end *after* calculating actions
    if (!game_over_ && valid_actions_cache_->empty())
    {
      force_game_over("No valid actions available.");
      // REMOVED C++ Log: std::cerr << "[GameStateCpp::get_valid_actions] Forced game over: No valid actions found after calculation." << std::endl;
    }
    return *valid_actions_cache_;
  }

  void GameStateCpp::invalidate_action_cache()
  {
    valid_actions_cache_ = std::nullopt;
  }

  // Make this non-const so it can modify the cache
  void GameStateCpp::calculate_valid_actions_internal() const // Keep const for now, use mutable cache
  {
    if (game_over_)
    {
      valid_actions_cache_ = std::set<Action>();
      // REMOVED C++ Log: std::cerr << "[GameStateCpp::calculate_valid_actions_internal] Game already over. Returning empty set." << std::endl;
      return;
    }
    std::set<Action> valid_actions;
    int can_place_true_count = 0; // Counter for debugging
    int attempts_count = 0;       // Counter for total placement checks

    for (int shape_idx = 0; shape_idx < static_cast<int>(shapes_.size()); ++shape_idx)
    {
      if (!shapes_[shape_idx].has_value())
        continue;
      const ShapeCpp &shape = shapes_[shape_idx].value();
      for (int r = 0; r < config_.rows; ++r)
      {
        const auto &[start_c, end_c] = config_.playable_range_per_row[r];
        for (int c = start_c; c < end_c; ++c)
        {
          attempts_count++;                                                       // Increment attempt counter
          bool can_place_result = grid_logic::can_place(grid_data_, shape, r, c); // Store result
          if (can_place_result)
          {
            valid_actions.insert(encode_action(shape_idx, r, c));
            can_place_true_count++; // Increment counter
          }
        }
      }
    }
    // REMOVED C++ Log:
    // std::cerr << "[GameStateCpp::calculate_valid_actions_internal] Step: " << current_step_
    //           << ", Attempts: " << attempts_count
    //           << ", CanPlaceTrue: " << can_place_true_count
    //           << ", ValidActionsFound: " << valid_actions.size()
    //           << std::endl;

    // Use mutable cache
    valid_actions_cache_ = std::move(valid_actions);
  }

  int GameStateCpp::get_current_step() const { return current_step_; }
  std::optional<std::string> GameStateCpp::get_game_over_reason() const { return game_over_reason_; }

  GameStateCpp GameStateCpp::copy() const
  {
    GameStateCpp newState = *this;
    // Copy the cache state explicitly
    if (this->valid_actions_cache_.has_value())
    {
      newState.valid_actions_cache_ = this->valid_actions_cache_;
    }
    else
    {
      newState.valid_actions_cache_ = std::nullopt;
    }
    return newState;
  }

  void GameStateCpp::debug_toggle_cell(int r, int c)
  {
    if (grid_data_.is_valid(r, c) && !grid_data_.is_death(r, c))
    {
      auto &occupied_grid = grid_data_.get_occupied_grid_mut();
      auto &color_grid = grid_data_.get_color_id_grid_mut();
      bool was_occupied = occupied_grid[r][c];
      occupied_grid[r][c] = !was_occupied;
      color_grid[r][c] = was_occupied ? NO_COLOR_ID : DEBUG_COLOR_ID;
      if (!was_occupied)
      {
        // Check for line clears only if a cell becomes occupied
        grid_logic::check_and_clear_lines(grid_data_, {{r, c}});
      }
      invalidate_action_cache(); // Always invalidate after manual change
    }
  }

  void GameStateCpp::debug_set_shapes(const std::vector<std::optional<ShapeCpp>> &new_shapes)
  {
    // Overwrite the current shapes with the provided ones.
    // Ensure the size matches the number of slots.
    size_t num_to_copy = std::min(new_shapes.size(), shapes_.size());
    for (size_t i = 0; i < num_to_copy; ++i)
    {
      shapes_[i] = new_shapes[i];
    }
    // Fill remaining slots with nullopt if new_shapes is shorter
    for (size_t i = num_to_copy; i < shapes_.size(); ++i)
    {
      shapes_[i] = std::nullopt;
    }
    // Invalidate cache as valid actions will change
    invalidate_action_cache();
  }

  Action GameStateCpp::encode_action(int shape_idx, int r, int c) const
  {
    int grid_size = config_.rows * config_.cols;
    if (shape_idx < 0 || shape_idx >= config_.num_shape_slots || r < 0 || r >= config_.rows || c < 0 || c >= config_.cols)
    {
      throw std::out_of_range("encode_action arguments out of range.");
    }
    return shape_idx * grid_size + r * config_.cols + c;
  }

  std::tuple<int, int, int> GameStateCpp::decode_action(Action action) const
  {
    int action_dim = config_.num_shape_slots * config_.rows * config_.cols;
    if (action < 0 || action >= action_dim)
    {
      throw std::out_of_range("Action index out of range: " + std::to_string(action));
    }
    int grid_size = config_.rows * config_.cols;
    int shape_idx = action / grid_size;
    int remainder = action % grid_size;
    int r = remainder / config_.cols;
    int c = remainder % config_.cols;
    return {shape_idx, r, c};
  }

} // namespace trianglengin::cpp

File: src/trianglengin/cpp/structs.h
// File: src/trianglengin/cpp/structs.h
#ifndef TRIANGLENGIN_CPP_STRUCTS_H
#define TRIANGLENGIN_CPP_STRUCTS_H

#pragma once

#include <vector>
#include <tuple>
#include <string>
#include <cstdint>
#include <utility> // For std::move

namespace trianglengin::cpp
{
  using Action = int;
  using Coord = std::tuple<int, int>;
  using ColorCpp = std::tuple<int, int, int>;
  using TriangleData = std::tuple<int, int, bool>;

  const int NO_COLOR_ID = -1;
  const int DEBUG_COLOR_ID = -2;

  struct ShapeCpp
  {
    std::vector<TriangleData> triangles;
    ColorCpp color;
    int color_id;

    ShapeCpp() : color_id(NO_COLOR_ID) {}
    ShapeCpp(std::vector<TriangleData> tris, ColorCpp c, int id)
        : triangles(std::move(tris)), color(c), color_id(id) {}

    bool operator==(const ShapeCpp &other) const
    {
      return triangles == other.triangles && color == other.color && color_id == other.color_id;
    }
  };
} // namespace trianglengin::cpp

#endif // TRIANGLENGIN_CPP_STRUCTS_H

File: src/trianglengin/cpp/bindings.cpp
// File: src/trianglengin/cpp/bindings.cpp
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/operators.h>
#include <pybind11/numpy.h>
#include <pybind11/functional.h> // Needed for std::function with optional
#include <vector>
#include <stdexcept>
#include <cstring>  // For memcpy with int8_t
#include <optional> // Include optional

#include "game_state.h"
#include "config.h"
#include "structs.h"

namespace py = pybind11;
namespace tg = trianglengin::cpp;

// Helper to convert Python EnvConfig to C++ EnvConfigCpp
tg::EnvConfigCpp python_to_cpp_env_config(const py::object &py_config)
{
  tg::EnvConfigCpp cpp_config;
  try
  {
    cpp_config.rows = py_config.attr("ROWS").cast<int>();
    cpp_config.cols = py_config.attr("COLS").cast<int>();
    cpp_config.num_shape_slots = py_config.attr("NUM_SHAPE_SLOTS").cast<int>();

    py::list py_ranges = py_config.attr("PLAYABLE_RANGE_PER_ROW").cast<py::list>();
    cpp_config.playable_range_per_row.clear();
    cpp_config.playable_range_per_row.reserve(py_ranges.size());
    for (const auto &item : py_ranges)
    {
      py::tuple range_tuple = item.cast<py::tuple>();
      if (range_tuple.size() != 2)
        throw std::runtime_error("Playable range tuple must have 2 elements.");
      cpp_config.playable_range_per_row.emplace_back(range_tuple[0].cast<int>(), range_tuple[1].cast<int>());
    }
    if (cpp_config.playable_range_per_row.size() != static_cast<size_t>(cpp_config.rows))
    {
      throw std::runtime_error("Mismatch between ROWS and PLAYABLE_RANGE_PER_ROW length.");
    }

    cpp_config.reward_per_placed_triangle = py_config.attr("REWARD_PER_PLACED_TRIANGLE").cast<double>();
    cpp_config.reward_per_cleared_triangle = py_config.attr("REWARD_PER_CLEARED_TRIANGLE").cast<double>();
    cpp_config.reward_per_step_alive = py_config.attr("REWARD_PER_STEP_ALIVE").cast<double>();
    cpp_config.penalty_game_over = py_config.attr("PENALTY_GAME_OVER").cast<double>();
    cpp_config.action_dim = cpp_config.num_shape_slots * cpp_config.rows * cpp_config.cols;
  }
  catch (const py::error_already_set &e)
  {
    throw std::runtime_error(std::string("Error accessing EnvConfig attributes: ") + e.what());
  }
  catch (const std::exception &e)
  {
    throw std::runtime_error(std::string("Error converting EnvConfig: ") + e.what());
  }
  return cpp_config;
}

// Helper to convert C++ optional<ShapeCpp> to Python tuple or None
py::object cpp_shape_to_python(const std::optional<tg::ShapeCpp> &shape_opt)
{
  if (!shape_opt)
    return py::none();
  const auto &shape = shape_opt.value();
  py::list triangles_py;
  for (const auto &tri : shape.triangles)
  {
    triangles_py.append(py::make_tuple(std::get<0>(tri), std::get<1>(tri), std::get<2>(tri)));
  }
  py::tuple color_py = py::make_tuple(std::get<0>(shape.color), std::get<1>(shape.color), std::get<2>(shape.color));
  return py::make_tuple(triangles_py, color_py, shape.color_id);
}

// Helper to convert Python tuple (or None) to C++ optional<ShapeCpp>
std::optional<tg::ShapeCpp> python_to_cpp_shape(const py::object &shape_py)
{
  if (shape_py.is_none())
  {
    return std::nullopt;
  }
  try
  {
    py::tuple shape_tuple = shape_py.cast<py::tuple>();
    if (shape_tuple.size() != 3)
    {
      throw std::runtime_error("Shape tuple must have 3 elements (triangles, color, id).");
    }

    py::list tris_py = shape_tuple[0].cast<py::list>();
    py::tuple color_py = shape_tuple[1].cast<py::tuple>();
    int id_py = shape_tuple[2].cast<int>();

    std::vector<tg::TriangleData> tris_cpp;
    tris_cpp.reserve(tris_py.size());
    for (const auto &tri_item : tris_py)
    {
      py::tuple tri_tuple = tri_item.cast<py::tuple>();
      if (tri_tuple.size() != 3)
      {
        throw std::runtime_error("Triangle tuple must have 3 elements (dr, dc, is_up).");
      }
      tris_cpp.emplace_back(tri_tuple[0].cast<int>(), tri_tuple[1].cast<int>(), tri_tuple[2].cast<bool>());
    }

    if (color_py.size() != 3)
    {
      throw std::runtime_error("Color tuple must have 3 elements (r, g, b).");
    }
    tg::ColorCpp color_cpp = {color_py[0].cast<int>(), color_py[1].cast<int>(), color_py[2].cast<int>()};

    return tg::ShapeCpp(std::move(tris_cpp), color_cpp, id_py);
  }
  catch (const py::error_already_set &e)
  {
    throw std::runtime_error(std::string("Error converting Python shape to C++: ") + e.what());
  }
  catch (const std::exception &e)
  {
    throw std::runtime_error(std::string("Error converting Python shape to C++: ") + e.what());
  }
}

PYBIND11_MODULE(trianglengin_cpp, m)
{
  m.doc() = "C++ core module for Trianglengin";

  py::class_<tg::GameStateCpp>(m, "GameStateCpp")
      .def(py::init([](const py::object &py_config, unsigned int seed)
                    {
                 tg::EnvConfigCpp cpp_config = python_to_cpp_env_config(py_config);
                 return std::make_unique<tg::GameStateCpp>(cpp_config, seed); }),
           py::arg("config"), py::arg("initial_seed"))
      .def("reset", &tg::GameStateCpp::reset)
      .def("step", &tg::GameStateCpp::step, py::arg("action"))
      .def("is_over", &tg::GameStateCpp::is_over)
      .def("get_score", &tg::GameStateCpp::get_score)
      .def("get_valid_actions", &tg::GameStateCpp::get_valid_actions, py::arg("force_recalculate") = false, py::return_value_policy::reference_internal)
      .def("get_current_step", &tg::GameStateCpp::get_current_step)
      .def("get_game_over_reason", &tg::GameStateCpp::get_game_over_reason)
      .def("get_shapes_cpp", [](const tg::GameStateCpp &gs)
           {
            py::list shapes_list;
            for(const auto& shape_opt : gs.get_shapes()) {
                shapes_list.append(cpp_shape_to_python(shape_opt));
            }
            return shapes_list; })
      .def("get_grid_occupied_flat", [](const tg::GameStateCpp &gs)
           {
            const auto& grid = gs.get_grid_data().get_occupied_grid();
            size_t rows = grid.size();
            size_t cols = (rows > 0) ? grid[0].size() : 0;
            py::array_t<bool> result({rows, cols});
            auto buf = result.request();
            bool *ptr = static_cast<bool *>(buf.ptr);
            // Manual copy for std::vector<bool>
            for (size_t r = 0; r < rows; ++r) {
                for (size_t c = 0; c < cols; ++c) {
                    ptr[r * cols + c] = grid[r][c];
                }
            }
            return result; })
      .def("get_grid_colors_flat", [](const tg::GameStateCpp &gs)
           {
            const auto& grid = gs.get_grid_data().get_color_id_grid();
            size_t rows = grid.size();
            size_t cols = (rows > 0) ? grid[0].size() : 0;
            py::array_t<int8_t> result({rows, cols});
            auto buf = result.request();
            int8_t *ptr = static_cast<int8_t *>(buf.ptr);
             // memcpy is fine for int8_t
             for (size_t r = 0; r < rows; ++r) {
                std::memcpy(ptr + r * cols, grid[r].data(), cols * sizeof(int8_t));
            }
            return result; })
      .def("get_grid_death_flat", [](const tg::GameStateCpp &gs)
           {
            const auto& grid = gs.get_grid_data().get_death_grid();
            size_t rows = grid.size();
            size_t cols = (rows > 0) ? grid[0].size() : 0;
            py::array_t<bool> result({rows, cols});
            auto buf = result.request();
            bool *ptr = static_cast<bool *>(buf.ptr);
            // Manual copy for std::vector<bool>
             for (size_t r = 0; r < rows; ++r) {
                for (size_t c = 0; c < cols; ++c) {
                    ptr[r * cols + c] = grid[r][c];
                }
            }
            return result; })
      .def("copy", &tg::GameStateCpp::copy)
      .def("debug_toggle_cell", &tg::GameStateCpp::debug_toggle_cell, py::arg("r"), py::arg("c"))
      // Add binding for debug_set_shapes
      .def("debug_set_shapes", [](tg::GameStateCpp &gs, const py::list &shapes_py)
           {
            std::vector<std::optional<tg::ShapeCpp>> shapes_cpp;
            shapes_cpp.reserve(shapes_py.size());
            for(const auto& shape_item_handle : shapes_py) {
                // Cast handle to object before passing to conversion function
                py::object shape_item = py::reinterpret_borrow<py::object>(shape_item_handle);
                shapes_cpp.push_back(python_to_cpp_shape(shape_item));
            }
            gs.debug_set_shapes(shapes_cpp); }, py::arg("new_shapes"), "Sets the shapes in the preview slots directly (for debugging/testing).");

#ifdef VERSION_INFO
  m.attr("__version__") = VERSION_INFO;
#else
  m.attr("__version__") = "dev";
#endif
}

File: src/trianglengin.egg-info/PKG-INFO
Metadata-Version: 2.4
Name: trianglengin
Version: 2.0.2
Summary: High-performance C++/Python engine for a triangle puzzle game.
Author-email: "Luis Guilherme P. M." <lgpelin92@gmail.com>
License-Expression: MIT
Project-URL: Homepage, https://github.com/lguibr/trianglengin
Project-URL: Bug Tracker, https://github.com/lguibr/trianglengin/issues
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: C++
Classifier: Operating System :: OS Independent
Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence
Classifier: Topic :: Games/Entertainment :: Puzzle Games
Classifier: Development Status :: 4 - Beta
Requires-Python: >=3.10
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: numpy>=1.20.0
Requires-Dist: pydantic>=2.0.0
Requires-Dist: typing_extensions>=4.0.0
Requires-Dist: pygame>=2.1.0
Requires-Dist: typer[all]>=0.9.0
Provides-Extra: dev
Requires-Dist: pytest>=7.0.0; extra == "dev"
Requires-Dist: pytest-cov>=3.0.0; extra == "dev"
Requires-Dist: pytest-mock>=3.0.0; extra == "dev"
Requires-Dist: ruff; extra == "dev"
Requires-Dist: mypy; extra == "dev"
Requires-Dist: build; extra == "dev"
Requires-Dist: twine; extra == "dev"
Requires-Dist: codecov; extra == "dev"
Dynamic: license-file


[![CI Status](https://github.com/lguibr/trianglengin/actions/workflows/ci_cd.yml/badge.svg)](https://github.com/lguibr/trianglengin/actions/workflows/ci_cd.yml)
[![codecov](https://codecov.io/gh/lguibr/trianglengin/graph/badge.svg?token=YOUR_CODECOV_TOKEN_HERE&flag=trianglengin)](https://codecov.io/gh/lguibr/trianglengin)
[![PyPI version](https://badge.fury.io/py/trianglengin.svg)](https://badge.fury.io/py/trianglengin)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Python Version](https://img.shields.io/badge/python-3.10+-blue.svg)](https://www.python.org/downloads/)

# Triangle Engine (`trianglengin`) v2
<img src="bitmap.png" alt="trianglengin logo" width="300"/>

**Version 2 introduces a high-performance C++ core for the game logic.**

This library provides the core components for a triangle puzzle game, suitable for reinforcement learning agents or other applications requiring a fast game engine. Interactive play/debug modes are included.

It encapsulates:

1.  **Core Game Logic (C++):** High-performance implementation of environment rules, state representation, actions, placement validation, and line clearing. ([`src/trianglengin/cpp/README.md`](src/trianglengin/cpp/README.md))
2.  **Python Interface:** A Python `GameState` wrapper providing a user-friendly API to interact with the C++ core. ([`src/trianglengin/game_interface.py`](src/trianglengin/game_interface.py))
3.  **Configuration (Python/Pydantic):** Models for environment settings (`EnvConfig`). ([`src/trianglengin/config/README.md`](src/trianglengin/config/README.md))
4.  **Utilities (Python):** General helpers, geometry functions, shared types. ([`src/trianglengin/utils/README.md`](src/trianglengin/utils/README.md))
5.  **UI Components (Python/Pygame/Typer):** Basic visualization, interaction handling, and CLI for interactive modes. ([`src/trianglengin/ui/README.md`](src/trianglengin/ui/README.md))

---

## ðŸŽ® The Ultimate Triangle Puzzle Guide ðŸ§©

*(Game rules remain the same)*

*(... Game rules section remains unchanged ...)*

---

## Purpose

The primary goal is to provide a self-contained, installable library with a high-performance C++ core and a Python interface for the triangle puzzle game. This allows different RL agent implementations or other applications to build upon a consistent and fast game backend. The interactive UI is included but only initialized when running the specific UI commands.

## Installation

**Prerequisites:**
*   A C++ compiler supporting C++17 (e.g., GCC, Clang, MSVC).
*   CMake (version 3.14 or higher).
*   Python (>= 3.10) and Pip.

```bash
# For standard use (once published or built):
pip install trianglengin

# Building from source (requires compiler and CMake):
git clone https://github.com/lguibr/trianglengin.git
cd trianglengin
pip install .
```
*(Note: `pygame` and `typer` will be installed as core dependencies).*

## Running Interactive Modes

After installing, you can run the interactive modes directly:

- **Play Mode:**
  ```bash
  trianglengin play [--seed 42] [--log-level INFO]
  ```
- **Debug Mode:**
  ```bash
  trianglengin debug [--seed 42] [--log-level DEBUG]
  ```

---

## Local Development & Testing

These instructions are for developers contributing to `trianglengin`.

1.  **Clone the Repository:**
    ```bash
    git clone https://github.com/lguibr/trianglengin.git
    cd trianglengin
    ```

2.  **Prerequisites:** Ensure you have a C++17 compiler and CMake installed.

3.  **Create and Activate Virtual Environment:** (venv or conda)
    ```bash
    # Example using venv
    python -m venv venv
    source venv/bin/activate # or .\venv\Scripts\activate on Windows
    ```
    **IMPORTANT:** Ensure your virtual environment is activated.

4.  **Install Build Dependencies:** (Needed even for core dev)
    ```bash
    pip install pybind11>=2.10 cmake wheel
    ```

5.  **Clean Previous Builds (Optional but Recommended):**
    ```bash
    rm -rf build/ src/trianglengin.egg-info/ dist/ src/trianglengin/trianglengin_cpp.*.so src/trianglengin/trianglengin_cpp*.cpp
    ```

6.  **Install in Editable Mode with Dev Dependencies:**
    *   **Make sure your virtual environment is active!**
    *   Run from the project root directory:
        ```bash
        # Installs core, UI, and dev tools
        pip install -e '.[dev]'
        ```
        This command compiles the C++ extension and installs the Python package so changes are reflected immediately. It also installs development tools.

7.  **Running Checks:**
    *   **Make sure your virtual environment is active!**
    *   **Tests & Coverage:**
        ```bash
        pytest tests/ --cov=src/trianglengin --cov-report=xml
        ```
        (Coverage measures core Python code, excluding UI).
        To just run tests: `pytest`
    *   **Linting:** `ruff check .`
    *   **Formatting:** `ruff format .`
    *   **Type Checking:** `mypy src/trianglengin/ tests/`

8.  **Troubleshooting Build/Import Errors:**
    *   Ensure compiler and CMake are installed and in PATH.
    *   Make sure the virtual environment is active *before* running `pip install -e`.
    *   Clean previous builds (Step 5).
    *   Check `pyproject.toml` and `setup.py` for correct configuration.
    *   Verify Pybind11 version compatibility.

---

## Project Structure (v2 - UI Included)

```
trianglengin/
â”œâ”€â”€ .github/workflows/      # GitHub Actions CI/CD
â”‚   â””â”€â”€ ci_cd.yml
â”œâ”€â”€ src/                    # Source root
â”‚   â””â”€â”€ trianglengin/       # Python package source
â”‚       â”œâ”€â”€ __init__.py     # Exposes core public API (GameState, EnvConfig, Shape)
â”‚       â”œâ”€â”€ game_interface.py # Python GameState wrapper class
â”‚       â”œâ”€â”€ py.typed        # PEP 561 marker
â”‚       â”œâ”€â”€ cpp/            # C++ Core Implementation ([src/trianglengin/cpp/README.md])
â”‚       â”‚   â”œâ”€â”€ CMakeLists.txt
â”‚       â”‚   â”œâ”€â”€ bindings.cpp
â”‚       â”‚   â”œâ”€â”€ config.h
â”‚       â”‚   â”œâ”€â”€ structs.h
â”‚       â”‚   â”œâ”€â”€ grid_data.h / .cpp
â”‚       â”‚   â”œâ”€â”€ grid_logic.h / .cpp
â”‚       â”‚   â”œâ”€â”€ shape_logic.h / .cpp
â”‚       â”‚   â””â”€â”€ game_state.h / .cpp
â”‚       â”œâ”€â”€ core/           # Core Python components (now minimal/empty)
â”‚       â”‚   â””â”€â”€ __init__.py
â”‚       â”œâ”€â”€ utils/          # General Python utilities ([src/trianglengin/utils/README.md])
â”‚       â”‚   â””â”€â”€ ... (geometry.py, types.py)
â”‚       â”œâ”€â”€ config/         # Core configuration models ([src/trianglengin/config/README.md])
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â””â”€â”€ env_config.py   # EnvConfig (Pydantic)
â”‚       â””â”€â”€ ui/             # UI Components ([src/trianglengin/ui/README.md])
â”‚           â”œâ”€â”€ __init__.py # Exposes UI API (Application, cli_app, DisplayConfig)
â”‚           â”œâ”€â”€ app.py      # Interactive mode application runner
â”‚           â”œâ”€â”€ cli.py      # CLI definition (play/debug)
â”‚           â”œâ”€â”€ config.py   # DisplayConfig (Pydantic)
â”‚           â”œâ”€â”€ interaction/    # User input handling ([src/trianglengin/ui/interaction/README.md])
â”‚           â”‚   â”œâ”€â”€ __init__.py
â”‚           â”‚   â”œâ”€â”€ event_processor.py
â”‚           â”‚   â”œâ”€â”€ input_handler.py
â”‚           â”‚   â”œâ”€â”€ play_mode_handler.py
â”‚           â”‚   â””â”€â”€ debug_mode_handler.py
â”‚           â””â”€â”€ visualization/  # Pygame rendering ([src/trianglengin/ui/visualization/README.md])
â”‚               â”œâ”€â”€ __init__.py
â”‚               â”œâ”€â”€ core/       # Core vis components ([src/trianglengin/ui/visualization/core/README.md])
â”‚               â”‚   â”œâ”€â”€ __init__.py
â”‚               â”‚   â”œâ”€â”€ colors.py
â”‚               â”‚   â”œâ”€â”€ coord_mapper.py
â”‚               â”‚   â”œâ”€â”€ fonts.py
â”‚               â”‚   â”œâ”€â”€ layout.py # NEW
â”‚               â”‚   â””â”€â”€ visualizer.py
â”‚               â””â”€â”€ drawing/    # Drawing functions ([src/trianglengin/ui/visualization/drawing/README.md])
â”‚                   â”œâ”€â”€ __init__.py
â”‚                   â”œâ”€â”€ grid.py
â”‚                   â”œâ”€â”€ highlight.py
â”‚                   â”œâ”€â”€ hud.py
â”‚                   â”œâ”€â”€ previews.py
â”‚                   â”œâ”€â”€ shapes.py
â”‚                   â””â”€â”€ utils.py
â”œâ”€â”€ tests/                  # Unit/Integration tests (Python) ([tests/README.md])
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ conftest.py
â”‚   â””â”€â”€ core/environment/
â”‚       â””â”€â”€ test_game_state.py # Tests the Python GameState wrapper
â”œâ”€â”€ .gitignore
â”œâ”€â”€ pyproject.toml          # Build config, dependencies
â”œâ”€â”€ setup.py                # C++ Extension build script
â”œâ”€â”€ README.md               # This file
â”œâ”€â”€ LICENSE
â””â”€â”€ MANIFEST.in
```

## Core Components (v2)

- **`trianglengin.cpp` (C++ Core)**: Implements the high-performance game logic (state, grid, shapes, rules). Not directly imported in Python.
- **`trianglengin.game_interface.GameState` (Python Wrapper)**: The primary Python class for interacting with the game engine. It holds a reference to the C++ game state object and provides methods like `step`, `reset`, `is_over`, `valid_actions`, `get_shapes`, `get_grid_data_np`.
- **`trianglengin.config.EnvConfig`**: Python Pydantic model for core environment configuration. Passed to C++ core during initialization.
- **`trianglengin.utils`**: General Python utility functions and types. ([`src/trianglengin/utils/README.md`](src/trianglengin/utils/README.md))

## UI Components (`trianglengin.ui`)

- **`trianglengin.ui.config.DisplayConfig`**: Pydantic model for UI display settings.
- **`trianglengin.ui.visualization`**: Python/Pygame rendering components. Uses data obtained from the `GameState` wrapper. ([`src/trianglengin/ui/visualization/README.md`](src/trianglengin/ui/visualization/README.md))
- **`trianglengin.ui.interaction`**: Python/Pygame input handling for interactive modes. Interacts with the `GameState` wrapper. ([`src/trianglengin/ui/interaction/README.md`](src/trianglengin/ui/interaction/README.md))
- **`trianglengin.ui.app.Application`**: Integrates UI components for interactive modes.
- **`trianglengin.ui.cli`**: Command-line interface (`trianglengin play`/`debug`).

## Contributing

Contributions are welcome! Please open an issue or submit a pull request on the [GitHub repository](https://github.com/lguibr/trianglengin). Ensure that changes maintain code quality (pass tests, linting, type checking) and keep READMEs updated. Building requires a C++17 compiler and CMake.


File: src/trianglengin.egg-info/SOURCES.txt
LICENSE
MANIFEST.in
README.md
pyproject.toml
setup.py
src/trianglengin/__init__.py
src/trianglengin/game_interface.py
src/trianglengin/py.typed
src/trianglengin.egg-info/PKG-INFO
src/trianglengin.egg-info/SOURCES.txt
src/trianglengin.egg-info/dependency_links.txt
src/trianglengin.egg-info/entry_points.txt
src/trianglengin.egg-info/not-zip-safe
src/trianglengin.egg-info/requires.txt
src/trianglengin.egg-info/top_level.txt
src/trianglengin/config/README.md
src/trianglengin/config/__init__.py
src/trianglengin/config/env_config.py
src/trianglengin/core/__init__.py
src/trianglengin/cpp/CMakeLists.txt
src/trianglengin/cpp/bindings.cpp
src/trianglengin/cpp/config.h
src/trianglengin/cpp/game_state.cpp
src/trianglengin/cpp/game_state.h
src/trianglengin/cpp/grid_data.cpp
src/trianglengin/cpp/grid_data.h
src/trianglengin/cpp/grid_logic.cpp
src/trianglengin/cpp/grid_logic.h
src/trianglengin/cpp/shape_logic.cpp
src/trianglengin/cpp/shape_logic.h
src/trianglengin/cpp/structs.h
src/trianglengin/ui/README.md
src/trianglengin/ui/__init__.py
src/trianglengin/ui/app.py
src/trianglengin/ui/cli.py
src/trianglengin/ui/config.py
src/trianglengin/ui/interaction/README.md
src/trianglengin/ui/interaction/__init__.py
src/trianglengin/ui/interaction/debug_mode_handler.py
src/trianglengin/ui/interaction/event_processor.py
src/trianglengin/ui/interaction/input_handler.py
src/trianglengin/ui/interaction/play_mode_handler.py
src/trianglengin/ui/visualization/README.md
src/trianglengin/ui/visualization/__init__.py
src/trianglengin/ui/visualization/core/README.md
src/trianglengin/ui/visualization/core/__init__.py
src/trianglengin/ui/visualization/core/colors.py
src/trianglengin/ui/visualization/core/coord_mapper.py
src/trianglengin/ui/visualization/core/fonts.py
src/trianglengin/ui/visualization/core/layout.py
src/trianglengin/ui/visualization/core/visualizer.py
src/trianglengin/ui/visualization/drawing/README.md
src/trianglengin/ui/visualization/drawing/__init__.py
src/trianglengin/ui/visualization/drawing/grid.py
src/trianglengin/ui/visualization/drawing/highlight.py
src/trianglengin/ui/visualization/drawing/hud.py
src/trianglengin/ui/visualization/drawing/previews.py
src/trianglengin/ui/visualization/drawing/shapes.py
src/trianglengin/ui/visualization/drawing/utils.py
src/trianglengin/utils/__init__.py
src/trianglengin/utils/geometry.py
src/trianglengin/utils/types.py
tests/__init__.py
tests/conftest.py
tests/core/__init__.py
tests/core/environment/README.md
tests/core/environment/__init__.py
tests/core/environment/test_game_state.py
tests/utils/__init__.py
tests/utils/test_geometry.py

File: src/trianglengin.egg-info/entry_points.txt
[console_scripts]
trianglengin = trianglengin.ui.cli:app


File: src/trianglengin.egg-info/requires.txt
numpy>=1.20.0
pydantic>=2.0.0
typing_extensions>=4.0.0
pygame>=2.1.0
typer[all]>=0.9.0

[dev]
pytest>=7.0.0
pytest-cov>=3.0.0
pytest-mock>=3.0.0
ruff
mypy
build
twine
codecov


File: src/trianglengin.egg-info/top_level.txt
trianglengin


File: src/trianglengin.egg-info/dependency_links.txt



